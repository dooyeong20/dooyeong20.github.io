<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans+KR:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;dooyeong20.github.io&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Pisces&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:true,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;Searching...&quot;,&quot;empty&quot;:&quot;We didn&#39;t find any results for the search: ${query}&quot;,&quot;hits_time&quot;:&quot;${hits} results found in ${time} ms&quot;,&quot;hits&quot;:&quot;${hits} results found&quot;}}</script>
<meta name="description" content="자바스크립트 프로토타입자바스크립트는 명령령, 함수형, 프로토타입 그리고 객체지향 기반의 프로그래밍을 지원하는 멀티 패러타임 프로그래밍 언어이다. 자바스크립트는 Java 의 public, private, 상속 등이 없어서 객체지향이 아니라고 오해를 받지만, 이러한 클래스 기반 객체지향이 아닌 프로토타입 기반의 강력한 객체지향 프로그래밍이 가능한 언어이다. 클">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 16 - Prototype (1)">
<meta property="og:url" content="https://dooyeong20.github.io/2021/05/22/javascript/day16/index.html">
<meta property="og:site_name" content="두영&#39;s 지식 공간">
<meta property="og:description" content="자바스크립트 프로토타입자바스크립트는 명령령, 함수형, 프로토타입 그리고 객체지향 기반의 프로그래밍을 지원하는 멀티 패러타임 프로그래밍 언어이다. 자바스크립트는 Java 의 public, private, 상속 등이 없어서 객체지향이 아니라고 오해를 받지만, 이러한 클래스 기반 객체지향이 아닌 프로토타입 기반의 강력한 객체지향 프로그래밍이 가능한 언어이다. 클">
<meta property="og:locale" content="ko_KR">
<meta property="article:published_time" content="2021-05-22T03:12:06.000Z">
<meta property="article:modified_time" content="2021-05-22T04:48:02.192Z">
<meta property="article:author" content="dooyeong">
<meta property="article:tag" content="javascript">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://dooyeong20.github.io/2021/05/22/javascript/day16/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;ko&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;https:&#x2F;&#x2F;dooyeong20.github.io&#x2F;2021&#x2F;05&#x2F;22&#x2F;javascript&#x2F;day16&#x2F;&quot;,&quot;path&quot;:&quot;2021&#x2F;05&#x2F;22&#x2F;javascript&#x2F;day16&#x2F;&quot;,&quot;title&quot;:&quot;JavaScript 16 - Prototype (1)&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>JavaScript 16 - Prototype (1) | 두영's 지식 공간</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">두영's 지식 공간</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">'진짜' 개발자가 되자 !</p>
      <img class="custom-logo-image" src="/images/devpost.jpg" alt="두영's 지식 공간">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>홈</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>카테고리<span class="badge">10</span></a></li>
        <li class="menu-item menu-item-자료구조-알고리즘"><a href="/categories/DS-Algorithm/" rel="section"><i class="fa fa-bookmark fa-fw"></i>자료구조 알고리즘</a></li>
        <li class="menu-item menu-item-html/css"><a href="/categories/HTML-CSS/" rel="section"><i class="fa fa-bookmark fa-fw"></i>HTML/CSS</a></li>
        <li class="menu-item menu-item-코딩테스트"><a href="/categories/Problem-Solving/" rel="section"><i class="fa fa-bookmark fa-fw"></i>코딩테스트</a></li>
        <li class="menu-item menu-item-javascript"><a href="/categories/JavaScript/" rel="section"><i class="fa fa-bookmark fa-fw"></i>JavaScript</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>태그<span class="badge">10</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>아카이브<span class="badge">78</span></a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          목차
        </li>
        <li class="sidebar-nav-overview">
          흝어보기
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85"><span class="nav-number">1.</span> <span class="nav-text">자바스크립트 프로토타입</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%ED%81%B4%EB%9E%98%EC%8A%A4"><span class="nav-number">1.1.</span> <span class="nav-text">클래스</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D"><span class="nav-number">1.2.</span> <span class="nav-text">객체지향 프로그래밍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EC%83%81%EC%86%8D%EA%B3%BC-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85"><span class="nav-number">1.3.</span> <span class="nav-text">상속과 프로토타입</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EA%B0%9D%EC%B2%B4"><span class="nav-number">1.4.</span> <span class="nav-text">프로토타입 객체</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#proto-%EC%A0%91%EA%B7%BC%EC%9E%90-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0"><span class="nav-number">1.4.1.</span> <span class="nav-text">__proto__ 접근자 프로퍼티</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%ED%95%A8%EC%88%98-%EA%B0%9D%EC%B2%B4%EC%9D%98-prototype-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0"><span class="nav-number">1.4.2.</span> <span class="nav-text">함수 객체의 prototype (프로퍼티)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%98-constructor-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EC%99%80-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98"><span class="nav-number">1.4.3.</span> <span class="nav-text">프로토타입의 constructor 프로퍼티와 생성자 함수</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EB%A6%AC%ED%84%B0%EB%9F%B4%EB%A1%9C-%EC%83%9D%EC%84%B1%ED%95%9C-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EC%99%80-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85"><span class="nav-number">1.5.</span> <span class="nav-text">리터럴로 생성한 객체의 생성자 함수와 프로토타입</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%83%9D%EC%84%B1-%EC%8B%9C%EC%A0%90"><span class="nav-number">1.6.</span> <span class="nav-text">프로토타입 생성 시점</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98"><span class="nav-number">1.6.1.</span> <span class="nav-text">사용자 정의 생성자 함수</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EB%B9%8C%ED%8A%B8%EC%9D%B8-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98"><span class="nav-number">1.6.2.</span> <span class="nav-text">빌트인 생성자 함수</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B8"><span class="nav-number">1.7.</span> <span class="nav-text">프로토타입 체인</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dooyeong"
      src="/images/my.png">
  <p class="site-author-name" itemprop="name">dooyeong</p>
  <div class="site-description" itemprop="description">좋은 개발자 기술 블로그</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">78</span>
          <span class="site-state-item-name">포스트</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">카테고리</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">태그</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dooyeong20" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dooyeong20" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:noviced22@gmail.com" title="E-Mail → mailto:noviced22@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dooyeong20" class="github-corner" title="Follow Github - dooyeong20" aria-label="Follow Github - dooyeong20" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://dooyeong20.github.io/2021/05/22/javascript/day16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my.png">
      <meta itemprop="name" content="dooyeong">
      <meta itemprop="description" content="좋은 개발자 기술 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="두영's 지식 공간">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaScript 16 - Prototype (1)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">작성일</span>
      

      <time title="Post created: 2021-05-22 12:12:06 / Updated at: 13:48:02" itemprop="dateCreated datePublished" datetime="2021-05-22T12:12:06+09:00">2021-05-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="자바스크립트-프로토타입"><a href="#자바스크립트-프로토타입" class="headerlink" title="자바스크립트 프로토타입"></a>자바스크립트 프로토타입</h1><p>자바스크립트는 명령령, 함수형, 프로토타입 그리고 객체지향 기반의 프로그래밍을 지원하는 <strong>멀티 패러타임</strong> 프로그래밍 언어이다.</p>
<p>자바스크립트는 Java 의 public, private, 상속 등이 없어서 객체지향이 아니라고 오해를 받지만, 이러한 클래스 기반 객체지향이 아닌 프로토타입 기반의 강력한 객체지향 프로그래밍이 가능한 언어이다.</p>
<h2 id="클래스"><a href="#클래스" class="headerlink" title="클래스"></a>클래스</h2><p>자바스크립트에도 ES6 에서 클래스가 도입되었는데, 기존의 프로토타입 기반의 객체지향 패러다임에서 아예 전환된 것이 아니라, 새로운 객체 생성 메커니즘이 하나 추가된 것이라고 볼 수 있다.</p>
<p>자바스크립트는 객체 기반의 프로그래밍 언어이고, 몇몇 원시타입을 제외하고는 모든 것이 객체이다. 함수, 배열, 정규표현식 등도 물론 객체이다.</p>
<h2 id="객체지향-프로그래밍"><a href="#객체지향-프로그래밍" class="headerlink" title="객체지향 프로그래밍"></a>객체지향 프로그래밍</h2><p>객체지향 프로그래밍(OOP) 란 프로그램을 명령어 뭉치, 함수 목록으로 취급하는 기존의 명령형 프로그래밍의 절차지향적 관점에서 탈피해 여러 개의 사물, 즉 객체의 집합으로 프로그램을 표현하는 패러다임이다.</p>
<p>객체지향은 실제 세계의 사물들을 프로그래밍 언어의 패러다임으로 표현하기 위해서 property와 attribute 등으로 표현하는 것이다. 그리고 이러한 객체들의 속성들 중에서 개발에 필요한 속성만 간추려서 사용할 수 있도록 추상화하는 과정을 거친다.</p>
<p>아래는 person 이라는 간단한 객체를 자바스크립트 문법으로 표현한 것이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;lee&#x27;</span>,</span><br><span class="line">  address: <span class="string">&#x27;seoul&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">talk</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> : hello !`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person);</span><br></pre></td></tr></table></figure>

<p>name과 address는 상태를 나타내는 데이터이며 talk는 동작(메서드)이다.</p>
<p>이렇듯 객체지향 프로그래밍은 상태와 동작을 하나의 단위로 묶어서 객체라는 단위를 가지고 프로그래밍을 하는 것이다. 그리고 이러한 객체들 사이에 서로 관계성을 가지며 서로 통신작용을 할 수 있는 것이다.</p>
<h2 id="상속과-프로토타입"><a href="#상속과-프로토타입" class="headerlink" title="상속과 프로토타입"></a>상속과 프로토타입</h2><p>상속은 객체지향의 핵심 개념이다. 어떠한 객체의 상태(프로퍼티)나 동작(메서드)을 그대로 물려받아 사용할 수 있는 것이다.</p>
<p>자바스크립트에서는 <strong>프로토타입</strong> 이라는 것을 기반으로 상속을 구현해 중복을 제거한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.radius = radius;</span><br><span class="line">  <span class="built_in">this</span>.getArea = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.PI * <span class="built_in">this</span>.radius ** <span class="number">2</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> Circle(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>예를 들어서 위의 Circle 이라는 생성자 함수로부터 아래 circle1과 circle2를 만들었다고 생각해보자. 그러면 getArea 라는 메서드는 각각 Circle의 인스턴스를 생성할 때마다 생성이 된다. 이렇게 되면 각각의 인스턴스들이 동일한 동작을 하는 함수를 각자 중복적으로 소유하고 있는 것인데 이는 메모리 비용상으로 합리적이지 않고 하나만 생성해내 모든 인스턴스가 공유해서 사용하는 것이 옳아보인다.</p>
<p>이 때 자바스크립트의 프로토타입 개념을 도입해 상속을 구현함으로써 중복을 제거해보겠다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Circle.prototype.getArea = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.PI * <span class="built_in">this</span>.radius ** <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> Circle(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>위의 <code>Circle.prototype.getArea</code> 에 함수를 할당해줌으로써 <code>Circle</code> 의 프로토타입에 함수를 할당해주는 것이다. 이렇게 되면 이제부터 Circle 생성자 함수를 통해 만든 인스턴스는 getArea를 공통적으로 소유(공유)할 수 있는 것이다.</p>
<h2 id="프로토타입-객체"><a href="#프로토타입-객체" class="headerlink" title="프로토타입 객체"></a>프로토타입 객체</h2><p>프로토타입은 객체이며, 객체지향 프로그래밍에서 중요한 개념인 <strong>상속</strong>을 구현하기 위해서 사용된다. 프로토타입이란, 한 객체의 부모 역할을 하는 객체로서 다른 객체들 사이의 공유 프로퍼티(메서드 포함)를 제공한다.</p>
<p>모든 객체는 <code>[[Prototype]]</code> 이라는 ‘내부 슬롯’ 을 가지며 이 내부 슬록의 값은 프로토타입의 참조이다. 객체가 생성될 때 객체 생성 방식에 따라서 프로토타입이 결정되어 <code>[[Prototype]]</code> 에 저장되는 것이다.</p>
<p><code>[[Prototype]]</code> 내부 슬록에는 직접 접근할 수 없지만, <code>__proto__</code> 접근자 프로퍼티를 통해서 자신의 프로토타입, 즉 <code>[[Prototype]]</code> 애 저장되어 있는 프로토타입 참조에 간접적으로 접근할 수 있다. 그리고 <code>생성자함수.prototype</code> 은 자신의 constructor 프로퍼티를 통해서 생성자 함수에 접근할 수 있고, 생성자 함수는 반대로 자신의 prototype 프로퍼티를 통해 프로토타입에 접근할 수 있게 되는 것이다.</p>
<h3 id="proto-접근자-프로퍼티"><a href="#proto-접근자-프로퍼티" class="headerlink" title="__proto__ 접근자 프로퍼티"></a><code>__proto__</code> 접근자 프로퍼티</h3><p>모든 객체는 <code>__proto__</code> 를 통해서 자신의 프로토타입에 간접적으로 접근할 수 있게 된다.</p>
<p>이 때 <code>__proto__</code> 는 접근자 프로퍼티라는 것이 중요하다. 내부 슬롯은 프로퍼티가 아니기 때문에, 내부 슬롯 및 내부 메서드에 직접 접근 및 호출할 수 있는 기능을 제공하지 않는다. 따라서 간접적으로 접근할 수 있도록 <code>__proto__</code> 를 제공하는 것이다.</p>
<p>그리고 <code>__proto__</code> 접근자 프로퍼티는 상속을 통해서 사용된다. <code>__proto__</code> 접근자 프로퍼티는 객체가 직접적으로 소유하는 프로퍼티가 아니라 <code>Object.prototype</code>의 프로퍼티이다.</p>
<blockquote>
<p><strong>Object.prototype</strong></p>
<p>모든 객체는 프로토타입의 계층 구조인 프로토타입 체인에 묶여 있다. 자바스크립트 엔진은 객체의 프로퍼티(메서드 포함)에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 <strong>proto</strong> 접근자 프로퍼티가 가리키는 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 프로토타입 체인의 종점, 즉 프로토타입 체인의 최상위 객체는 Object.prototype이며, 이 객체의 프로퍼티와 메서드는 모든 객체에게 상속된다.</p>
</blockquote>
<p>코드 내에서 <code>__proto__</code> 를 직접 사용하는 것을 좋지 않다. 왜냐하면 <code>Object.create(null)</code> 과 같이 프로토타입 체인의 종점인 객체를 생성하면 <code>__proto__</code> 를 상속받을 수 없기 때문이다.</p>
<p><code>__proto__</code> 접근자 프로퍼티 대신 프로토타입의 참조를 취득하고 싶은 경우에는 Object.getPrototypeOf 메서드를 사용하고, 프로토타입을 교체하고 싶은 경우에는 <code>Object.setPrototypeOf</code> 메서드를 사용하면 된다.</p>
<h3 id="함수-객체의-prototype-프로퍼티"><a href="#함수-객체의-prototype-프로퍼티" class="headerlink" title="함수 객체의 prototype (프로퍼티)"></a>함수 객체의 prototype (프로퍼티)</h3><p>prototype 이라는 말이 너무 자주 출몰해서 헷갈릴 수 있기 때문에 개념 정립을 확실히 해두어야 한다. ‘prototype 프로퍼티’ 는 함수 객체만이 소유할 수 있고, 이는 생성자 함수가 생성하는 인스턴스의 프로토타입을 가리킨다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;.hasOwnProperty(<span class="string">&#x27;prototype&#x27;</span>)); <span class="comment">// -&gt; true</span></span><br><span class="line"></span><br><span class="line">(&#123;&#125;.hasOwnProperty(<span class="string">&#x27;prototype&#x27;</span>)); <span class="comment">// -&gt; false</span></span><br></pre></td></tr></table></figure>

<p>설명에서처럼, ‘생성자’ 함수가 가질 수 있는 것이기 때문에 arrow function 이나 ES6 메서드 축약 표현으로 정의한 메서드는 prototype 프로퍼티를 가질 수 없는 것이다.</p>
<p>모든 객체가 가지고 있는 <code>__proto__</code> 접근자 프로퍼티와 함수 객체만이 가지고 있는 prototype 프로퍼티는 결국 동일한 프로토타입을 가리킨다. 하지만 이들 프로퍼티를 사용하는 주체가 다르다.</p>
<ul>
<li><p><code>__proto__</code> 접근자 프로퍼티</p>
<ul>
<li>소유: 모든 객체</li>
<li>값: 프로토타입 참조</li>
<li>사용 주체: 모든 객체</li>
<li>사용 목적: 객체가 자신의 프로토타입에 접근 &amp; 교체하기 위해</li>
</ul>
</li>
<li><p><code>prototype</code> 프로퍼티</p>
<ul>
<li>소유: 생성자 함수(constructor)</li>
<li>값: 프로토타입 참조</li>
<li>사용 주체: 생성자 함수</li>
<li>자신이 생성할 객체(인스턴스)의 프로토타입을 할당하기 위해 사용</li>
</ul>
</li>
</ul>
<p>이 차이에 대한 내용은 매우 헷갈릴 수 있다. 아래 예시를 보자.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person.prototype과 me.__proto__는 결국 동일한 프로토타입을 가리킨다.</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype === me.__proto__); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="프로토타입의-constructor-프로퍼티와-생성자-함수"><a href="#프로토타입의-constructor-프로퍼티와-생성자-함수" class="headerlink" title="프로토타입의 constructor 프로퍼티와 생성자 함수"></a>프로토타입의 constructor 프로퍼티와 생성자 함수</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(me.constructor === Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>위 예제에서 Person 생성자 함수는 me 객체를 생성했다. 이때 me 객체는 프로토타입의 constructor 프로퍼티를 통해 생성자 함수와 연결된다. me 객체에는 constructor 프로퍼티가 없지만 me 객체의 프로토타입인 Person.prototye에는 constructor 프로퍼티가 있다. 따라서 me 객체는 프로토타입인 Person.prototye의 constructor 프로퍼티를 상속받아 사용할 수 있다.</p>
<h2 id="리터럴로-생성한-객체의-생성자-함수와-프로토타입"><a href="#리터럴로-생성한-객체의-생성자-함수와-프로토타입" class="headerlink" title="리터럴로 생성한 객체의 생성자 함수와 프로토타입"></a>리터럴로 생성한 객체의 생성자 함수와 프로토타입</h2><p>앞서서 살펴본대로, 생성자 함수로 생성된 객체(인스턴스)는 프로토타입의 constructor 프로퍼티로 자신의 생성자 함수를 참조할 수 있다.</p>
<p>하지만, 생성자 함수가 없는 리터럴 객체 생성 방식의 경우에는 어떨까?</p>
<p>리터럴로 생성한 객체도 당연하게도 프로토타입이 존재한다. 하지만 이 경우에는 constructor가 가리키는 생성자 함수가 자신을 생성한 생성자 함수인 것을 보장하지 않는다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.constructor === <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function 생성자 함수로 생성한 함수 객체가 아니라 함수 선언문으로 생성했다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo의 생성자 함수는 Function 생성자 함수라고 판단하고 있다.</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.constructor === <span class="built_in">Function</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>위 의 객체들은 생성자 함수로 생성한 객체가 아닌데도 Object, Function 객체를 생성자 함수로써 참조하고 있다.</p>
<p>리터럴 표기법에 의해 생성된 객체도 상속을 위해 프로토타입이 필요하기 때문에 리터럴 표기법에 의해 생성된 객체도 가상적인 생성자 함수를 가지기 때문에 이러한 현상이 발생하는 것이다.</p>
<p>프로토타입은 생성자 함수와 더불어 생성되며 prototype, constructor 프로퍼티에 의해 연결되어 있기 때문이다. 즉, 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍(pair)으로 존재한다.</p>
<p>리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입은 다음과 같다.</p>
<ul>
<li><p>객체 리터럴</p>
<ul>
<li>생성자 함수: Object</li>
<li>프로토타입: Object.prototype</li>
</ul>
</li>
<li><p>함수 리터럴</p>
<ul>
<li>생성자 함수: Function</li>
<li>프로토타입: Function.prototype</li>
</ul>
</li>
<li><p>배열 리터럴</p>
<ul>
<li>생성자 함수: Array</li>
<li>프로토타입: Array.prototype</li>
</ul>
</li>
<li><p>정규 표현식 리터럴</p>
<ul>
<li>생성자 함수: RegExp</li>
<li>프로토타입: RegExp.prototype</li>
</ul>
</li>
</ul>
<h2 id="프로토타입-생성-시점"><a href="#프로토타입-생성-시점" class="headerlink" title="프로토타입 생성 시점"></a>프로토타입 생성 시점</h2><p>모든 객체는 결국 생성자 함수와 연결되어 있다는 사실을 알 수 있다. 그럼 프로토타입은 언제 생성될까?</p>
<p>프로토타입은 생성자 함수가 생성되는 시점에 함께 생성된다. 프로토타입과 생성자 함수는 항상 쌍으로 존재하기 때문이다.</p>
<h3 id="사용자-정의-생성자-함수"><a href="#사용자-정의-생성자-함수" class="headerlink" title="사용자 정의 생성자 함수"></a>사용자 정의 생성자 함수</h3><p>내부 메서드 <code>[[Construct]]</code> 를 가지는 함수 객체는 new 연산자로 생성자 함수로써 호출할 수 있다. 이러한 constructor 함수는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 함께 prototype 이 생성된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 평가되어 함수 객체 Person 이 생성될 때 prototype 도 함께 생성</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arrow function은 non-constructor 이기 때문에 prototype이 생성되지 않음</span></span><br><span class="line"><span class="keyword">const</span> Person2 = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>참고로 이 때 생성된 프로토타입의 프로토타입은 Object.prototype 이 된다.</p>
<h3 id="빌트인-생성자-함수"><a href="#빌트인-생성자-함수" class="headerlink" title="빌트인 생성자 함수"></a>빌트인 생성자 함수</h3><p>Object, String, Number, Function, Array, RegExp, Date, Promise 같은 빌트인 생성자 함수도 생성자 함수가 생성되는 시점에 프로토타입이 생성된다. 그리고 모든 빌트인 생성자 함수는 전역 객체(window 등)가 생성될 때 생성된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// browser</span></span><br><span class="line"><span class="built_in">window</span>.Object === <span class="built_in">Object</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>이처럼 생성자 함수와 프로토타입은 이미 객체화되어 존재한다. 이후 생성자 함수 또는 리터럴 표기법으로 객체를 생성하면 프로토타입은 생성된 객체의 <code>[[Prototype]]</code> 내부 슬롯에 할당된다.</p>
<h2 id="프로토타입-체인"><a href="#프로토타입-체인" class="headerlink" title="프로토타입 체인"></a>프로토타입 체인</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Hi! My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(me.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>이 때, me 객체는 자신을 생성한 함수인 Person의 prototype을 상속받았기 때문에 sayHello 라는 메서드를 사용할 수 있게 된 것이고, Person의 prototype이 Object의 prototype을 상속받았기 때문 hasOwnProperty 메서드도 사용할 수있는 것이다. 즉, 스코프를 배웠을 때와 마찬가지로 프로토타입도 프로토타입 체인을 타고 검색한다는 것을 의미한다.</p>
<p>즉, 자바스크립트는 객체의 프로퍼티(메서드 포함)에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 <code>[[Prototype]]</code> 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 이를 프로토타입 체인이라 하는 것이다. 프로토타입 체인은 자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 메커니즘이다.</p>
<p>프로토타입 체인의 최상위에 위치하는 객체는 언제나 <code>Object.prototype</code> 이다. 즉, bject.prototype을 프로토타입 체인의 종점(end of prototype chain)이라 한다.</p>
<p>Object.prototype의 프로토타입, 즉 <code>[[Prototype]]</code> 내부 슬롯의 값은 null이다.</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/javascript/" rel="tag"><i class="fa fa-tag"></i> javascript</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/05/21/javascript/day15/" rel="prev" title="JavaScript 15 - 일급 객체">
                  <i class="fa fa-chevron-left"></i> JavaScript 15 - 일급 객체
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/05/22/javascript/day17/" rel="next" title="JavaScript 17 - Prototype (2)">
                  JavaScript 17 - Prototype (2) <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>





<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dooyeong</span>
</div>

    </div>
  </footer>

  
  <script size="100" alpha="0.3" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  <script class="next-config" data-name="nprogress" type="application/json">{&quot;enable&quot;:true,&quot;spinner&quot;:true}</script>
  <script src="/js/third-party/nprogress.js"></script>

  





</body>
</html>
