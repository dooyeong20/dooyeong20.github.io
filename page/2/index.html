<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans+KR:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;dooyeong20.github.io&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Pisces&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:true,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;Searching...&quot;,&quot;empty&quot;:&quot;We didn&#39;t find any results for the search: ${query}&quot;,&quot;hits_time&quot;:&quot;${hits} results found in ${time} ms&quot;,&quot;hits&quot;:&quot;${hits} results found&quot;}}</script>
<meta name="description" content="좋은 개발자 기술 블로그">
<meta property="og:type" content="website">
<meta property="og:title" content="두영&#39;s 지식 공간">
<meta property="og:url" content="https://dooyeong20.github.io/page/2/index.html">
<meta property="og:site_name" content="두영&#39;s 지식 공간">
<meta property="og:description" content="좋은 개발자 기술 블로그">
<meta property="og:locale" content="ko_KR">
<meta property="article:author" content="dooyeong">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://dooyeong20.github.io/page/2/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;ko&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;page&#x2F;2&#x2F;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>두영's 지식 공간 - '진짜' 개발자가 되자 !</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">두영's 지식 공간</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">'진짜' 개발자가 되자 !</p>
      <img class="custom-logo-image" src="/images/devpost.jpg" alt="두영's 지식 공간">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>홈</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>카테고리<span class="badge">10</span></a></li>
        <li class="menu-item menu-item-자료구조-알고리즘"><a href="/categories/DS-Algorithm/" rel="section"><i class="fa fa-bookmark fa-fw"></i>자료구조 알고리즘</a></li>
        <li class="menu-item menu-item-html/css"><a href="/categories/HTML-CSS/" rel="section"><i class="fa fa-bookmark fa-fw"></i>HTML/CSS</a></li>
        <li class="menu-item menu-item-코딩테스트"><a href="/categories/Problem-Solving/" rel="section"><i class="fa fa-bookmark fa-fw"></i>코딩테스트</a></li>
        <li class="menu-item menu-item-javascript"><a href="/categories/JavaScript/" rel="section"><i class="fa fa-bookmark fa-fw"></i>JavaScript</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>태그<span class="badge">10</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>아카이브<span class="badge">79</span></a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          목차
        </li>
        <li class="sidebar-nav-overview">
          흝어보기
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dooyeong"
      src="/images/my.png">
  <p class="site-author-name" itemprop="name">dooyeong</p>
  <div class="site-description" itemprop="description">좋은 개발자 기술 블로그</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">79</span>
          <span class="site-state-item-name">포스트</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">카테고리</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">태그</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dooyeong20" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dooyeong20" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:noviced22@gmail.com" title="E-Mail → mailto:noviced22@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dooyeong20" class="github-corner" title="Follow Github - dooyeong20" aria-label="Follow Github - dooyeong20" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dooyeong20.github.io/2021/05/23/javascript/day18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my.png">
      <meta itemprop="name" content="dooyeong">
      <meta itemprop="description" content="좋은 개발자 기술 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="두영's 지식 공간">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/23/javascript/day18/" class="post-title-link" itemprop="url">JavaScript 18 - strict mode</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">작성일</span>
      

      <time title="Post created: 2021-05-23 12:35:06 / Updated at: 13:01:50" itemprop="dateCreated datePublished" datetime="2021-05-23T12:35:06+09:00">2021-05-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="strict-mode"><a href="#strict-mode" class="headerlink" title="strict mode"></a>strict mode</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(y); <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p>위 코드를 보면 foo 함수 내에서 <code>x = 10</code> 을 수행하기 위해서 foo 함수 스코프에서 <code>x</code> 를 검색한다. 하지만 당연히 없고, 그럼 다음으로 상위 스코프인 전역 스코프에서 x 선언을 검색하지만 전역에도 없고, 따라서 엥ㄴ진이 <strong>암묵적으로</strong> 전역 객체에 <code>x</code> 프로퍼티를 동적으로 생성한다.</p>
<p>개발자의 의도와 상관없이 발생하는 암묵적 전역은 오류를 발생시킬 가능성이 매우 높기 때문에 <code>let</code>, <code>const</code> 와같은 키워드를 사용해 변수를 선언한 다음에 사용해야 한다.</p>
<p>하지만 오타, 문법 지식의 미비로 인해서 실수를 발생시킬 수 있으므로 잠재적인 오류를 억제해주는 개발 환경을 만들 수 있는데, 그 중 한 방법이 바로 ES5 부터 도입된 strict mode 이다. 이는 자바스크립트의 문법을 더 엄격히 적용해 오류를 발생시킬 확률이 높거나 문제를 일으킬 수 있는 코드에 대해서 명시적으로 에러를 발생시킨다.</p>
<p>ESLint 와 같은 도구를 사용해도 strict mode 가 발생시키는 오류는 기본적으로 제공하며 더 나아가 코딩 컨벤션, 제안 사항 등 원하는 설정을 적용할 수 있어서 ESLint 를 선호하는 개발자들이 많다.</p>
<blockquote>
<p>ES6에서 도입된 클래스와 모듈은 기본적으로 strict mode가 적용된다.</p>
</blockquote>
<h2 id="strict-mode-의-적용"><a href="#strict-mode-의-적용" class="headerlink" title="strict mode 의 적용"></a>strict mode 의 적용</h2><p>strict mode 를 적용하는 방법은 간단하다. 전역의 선두에 <code>&#39;use strict&#39;;</code> 를 추가해주면 된다.</p>
<p>그리고 비슷한 원리로 만약 함수 몸체의 선두에 추가하면 해당 함수와 내부 함수에 strict mode 가 적용된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  x = <span class="number">10</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<h2 id="strict-mode-주의-사항"><a href="#strict-mode-주의-사항" class="headerlink" title="strict mode 주의 사항"></a>strict mode 주의 사항</h2><h3 id="전역에-strict-mode-를-적용하지-말자"><a href="#전역에-strict-mode-를-적용하지-말자" class="headerlink" title="전역에 strict mode 를 적용하지 말자"></a>전역에 strict mode 를 적용하지 말자</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="meta">  &#x27;use strict&#x27;</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  x = <span class="number">1</span>; <span class="comment">// 에러가 발생하지 않는다.</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(x); <span class="comment">// 1</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="meta">  &#x27;use strict&#x27;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  y = <span class="number">1</span>; <span class="comment">// ReferenceError: y is not defined</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(y);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>위의 경우에, script 단위로 적용이되어버려 아래에 strict mode 가 적용되지 않는다. 따라서 이 방법 대신에 즉시 실행 함수로 스크립트의 전체를 감싸서 스코프를 구분해준 다음 해당 함수 선두에 strict mode 를 적용해주면 된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h3 id="함수-단위로-strict-mode-를-사용하지-말자"><a href="#함수-단위로-strict-mode-를-사용하지-말자" class="headerlink" title="함수 단위로 strict mode 를 사용하지 말자"></a>함수 단위로 strict mode 를 사용하지 말자</h3><p>어떤 함수는 strict mode를 적용하고 어떤 함수는 적용하지 않는 것은 합리적이지 않다. 그리고 모든 함수에 일일이 strict mode를 적용하는 것은 번거롭다.</p>
<p>또한 만약 strict mode가 적용된 함수가 참조할 함수 외부의 컨텍스트에 strict mode를 적용하지 않는다면 원하는 대로 동작하지 않을 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// non-strict mode</span></span><br><span class="line">  <span class="keyword">var</span> lеt = <span class="number">10</span>; <span class="comment">// 에러 X</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    &#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> = <span class="number">20</span>; <span class="comment">// 에러 O</span></span><br><span class="line">  &#125;</span><br><span class="line">  foo();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>따라서 strict mode 는 즉시 실행 함수로 감싼 스크립트 단위로 적용하면 좋다.</p>
<h2 id="strict-mode-의-에러"><a href="#strict-mode-의-에러" class="headerlink" title="strict mode 의 에러"></a>strict mode 의 에러</h2><h3 id="1-암묵적-전역"><a href="#1-암묵적-전역" class="headerlink" title="1. 암묵적 전역"></a>1. 암묵적 전역</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  x = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h3 id="2-변수-함수-매개변수의-삭제"><a href="#2-변수-함수-매개변수의-삭제" class="headerlink" title="2. 변수, 함수, 매개변수의 삭제"></a>2. 변수, 함수, 매개변수의 삭제</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">delete</span> x;</span><br><span class="line">  <span class="comment">// SyntaxError: Delete of an unqualified identifier in strict mode.</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line">    <span class="comment">// SyntaxError: Delete of an unqualified identifier in strict mode.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> foo;</span><br><span class="line">  <span class="comment">// SyntaxError: Delete of an unqualified identifier in strict mode.</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<h3 id="3-매개변수-이름-중복"><a href="#3-매개변수-이름-중복" class="headerlink" title="3. 매개변수 이름 중복"></a>3. 매개변수 이름 중복</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//SyntaxError: Duplicate parameter name not allowed in this context</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(foo(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h3 id="4-with-문의-사용"><a href="#4-with-문의-사용" class="headerlink" title="4. with 문의 사용"></a>4. <code>with</code> 문의 사용</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// SyntaxError: Strict mode code may not include a with statement</span></span><br><span class="line">  <span class="keyword">with</span> (&#123; <span class="attr">x</span>: <span class="number">1</span> &#125;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h2 id="strict-mode-적용에-의한-변화"><a href="#strict-mode-적용에-의한-변화" class="headerlink" title="strict mode 적용에 의한 변화"></a>strict mode 적용에 의한 변화</h2><h3 id="1-일반-함수의-this"><a href="#1-일반-함수의-this" class="headerlink" title="1. 일반 함수의 this"></a>1. 일반 함수의 this</h3><p>strict mode 에서는 함수를 일반 함수로써 호출하면 <code>this</code> 에 <code>undefined</code> 가 바인딩된다. 왜냐하면 일반 함수 내부에서는 <code>this</code> 가 사용될 필요가 없기 때문이다. 참고로 에러는 발생하지 않는다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  foo();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// Foo</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">new</span> Foo();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h3 id="2-arguments-객체"><a href="#2-arguments-객체" class="headerlink" title="2. arguments 객체"></a>2. arguments 객체</h3><p>strict mode 에서는 매개변수에 저달된 인수를 재할당해서 변경해도 arguments 객체에 반영되지 않는다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  a = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">// &#123; 0: 1, length: 1 &#125; 변경되지 않음</span></span><br><span class="line">&#125;)(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dooyeong20.github.io/2021/05/22/javascript/day17/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my.png">
      <meta itemprop="name" content="dooyeong">
      <meta itemprop="description" content="좋은 개발자 기술 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="두영's 지식 공간">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/22/javascript/day17/" class="post-title-link" itemprop="url">JavaScript 17 - Prototype (2)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">작성일</span>
      

      <time title="Post created: 2021-05-22 13:47:06 / Updated at: 14:57:12" itemprop="dateCreated datePublished" datetime="2021-05-22T13:47:06+09:00">2021-05-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="자바스크립트-프로토타입"><a href="#자바스크립트-프로토타입" class="headerlink" title="자바스크립트 프로토타입"></a>자바스크립트 프로토타입</h1><h2 id="오버라이딩과-프로퍼티-섀도잉"><a href="#오버라이딩과-프로퍼티-섀도잉" class="headerlink" title="오버라이딩과 프로퍼티 섀도잉"></a>오버라이딩과 프로퍼티 섀도잉</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로토타입 메서드</span></span><br><span class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Hi! My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스 메서드</span></span><br><span class="line">me.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Hey! My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스 메서드가 호출된다. 프로토타입 메서드는 인스턴스 메서드에 의해 가려진다.</span></span><br><span class="line">me.sayHello(); <span class="comment">// Hey! My name is Lee</span></span><br></pre></td></tr></table></figure>

<p>프로토타입 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가하면 프로토타입 체인을 따라 프로토타입 프로퍼티를 검색하여 프로토타입 프로퍼티를 덮어쓰는 것이 아니라 인스턴스 프로퍼티로 추가한다. 이 때 인스턴스 메서드인 sayHello 가 프로토타입 메서드인 sayHello 를 오버라이딩했고, 프로토타입 메서드는 인스턴스 매서드에 의해 가려진다. 이렇듯 상속 관계에 의해 프로퍼티가 가려지는듯한 현상을 프로퍼티 섀도잉이라고 한다.</p>
<blockquote>
<p>오버라이딩(overriding)<br>상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의하여 사용하는 방식이다.</p>
</blockquote>
<blockquote>
<p>오버로딩(overloading)<br>함수의 이름은 동일하지만 매개변수의 타입 또는 개수가 다른 메서드를 구현하고 매개변수에 의해 메서드를 구별하여 호출하는 방식이다. 자바스크립트는 오버로딩을 지원하지 않지만 arguments 객체를 사용하여 구현할 수는 있다.</p>
</blockquote>
<p>인스턴스가 자신의 메서드 등의 프로퍼티를 삭제하는 것은 가능하지만, 자신보다 상위의 (프로토타입의) 프로퍼티를 변경하거나 삭제하는 것은 불가능하다. 즉, get 액세스는 허용되지만 set 액세스는 허용되지 않는 것이다.</p>
<p>만약 프로토타입의 프로퍼티를 변경하거나 삭제하기 위해서는 프로토타입 체인으로 접근하는 것이 아니라, 프로토타입에 직접 접근해야 한다.</p>
<h2 id="프로토타입의-교체"><a href="#프로토타입의-교체" class="headerlink" title="프로토타입의 교체"></a>프로토타입의 교체</h2><p>프로토타입은 객체이기 때문에 다른 객체로 변경할 수 있다. 즉, 부모역할을 하는 객체인 프로토타입을 동적으로 변경할 수 있다는 뜻이다. 이런 특징을 활용하면 객체간의 상속 관계를 동적으로 변경할 수도 있게되며 생성자 함수 또는 인스턴스로 교체할 수 있다.</p>
<h3 id="생성자-함수에-의한-프로토타입의-교체"><a href="#생성자-함수에-의한-프로토타입의-교체" class="headerlink" title="생성자 함수에 의한 프로토타입의 교체"></a>생성자 함수에 의한 프로토타입의 교체</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 프로토타입 리터럴로 교체</span></span><br><span class="line">  Person.prototype = &#123;</span><br><span class="line">    <span class="comment">// constructor: Person, 살릴려면 주석을 해제하면 됨</span></span><br><span class="line">    <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Hi! My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Person;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(me.constructor === Person); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(me.constructor === <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>프로토타입으로 교체한 객체 리터럴에는 constructor 프로퍼티가 없다. constructor 프로퍼티는 자바스크립트 엔진이 프로토타입을 생성할 때 암묵적으로 추가한 프로퍼티다. 따라서 me 객체의 생성자 함수를 검색하면 Person이 아닌 Object가 나온다.</p>
<h3 id="인스턴스에-의한-프로토타입의-교체"><a href="#인스턴스에-의한-프로토타입의-교체" class="headerlink" title="인스턴스에 의한 프로토타입의 교체"></a>인스턴스에 의한 프로토타입의 교체</h3><p>인스턴스의 <code>__proto__</code> 접근자 프로퍼티(또는 Object.setPrototypeOf 메서드)를 통해 프로토타입을 교체할 수 있다. 생성자 함수의 prototype 프로퍼티에 임의의 객체를 바인딩하여 프로토타입을 교체할 수 있다. <code>__proto__</code> 접근자 프로퍼티를 사용해 프로토타입을 교체하는 것은 이미 생성된 객체의 프로토타입을 교체하는 것이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 교체할 객체</span></span><br><span class="line"><span class="keyword">const</span> parent = &#123;</span><br><span class="line">  <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi! My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// me 객체의 프로토타입을 parent 객체로 교체한다.</span></span><br><span class="line">me.__proto__ = parent;</span><br><span class="line"><span class="comment">// Object.setPrototypeOf(me, parent);</span></span><br><span class="line"></span><br><span class="line">me.sayHello(); <span class="comment">// Hi! My name is Lee</span></span><br></pre></td></tr></table></figure>

<p>생성자 함수에 의한 교체와 인스턴스에 의한 교체는 차이가 없어보이지만 사실 차이가 있다. Person.prototype 이 교체된 객체를 가리키는지 아닌지에 차이가 있는데, 인스턴스에 의해서 변경된 객체는 Person.prototype이 가리키지 못한다.</p>
<p>이처럼 프로토타입 교체를 통해 객체 간의 상속 관계를 동적으로 변경하는 것은 꽤나 번거롭다. 따라서 프로토타입은 직접 교체하지 않는 것이 좋다. 상속 관계를 인위적으로 설정하려면 ‘직접 상속’ 이 더 편리하고 안전하다. 또는 ES6에서 도입된 클래스를 사용하면 간편하고 직관적으로 상속 관계를 구현할 수 있다.</p>
<h3 id="instanceof-연산자"><a href="#instanceof-연산자" class="headerlink" title="instanceof 연산자"></a>instanceof 연산자</h3><p><code>instanceof</code> 연사나자는 좌변의 객체의 프로토타입 체인에 우변의 생성자 함수의 prototype(이 참조하고 있는 객체) 이 존재하면 true 이고, 아니면 false 이다.</p>
<p><code>instanceof</code> 연산자는 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수를 찾는 것이 아니라, 생성자 함수의 prototype에 바인딩된 객체가 프로토타입 체인 상에 존재하는지 확인한다.</p>
<blockquote>
<p>즉, me instanceof Person의 경우, me 객체의 프로토타입 체인 상에 Person.prototype에 바인딩된 객체가 존재하는지 확인한다.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체</span></span><br><span class="line">  Person.prototype = &#123;</span><br><span class="line">    <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Hi! My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Person;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// constructor 프로퍼티와 생성자 함수 간의 연결은 파괴되어도 instanceof는 아무런 영향을 받지 않는다.</span></span><br><span class="line"><span class="built_in">console</span>.log(me.constructor === Person); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// me.constructor === Object</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(me <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(me <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="직접-상속"><a href="#직접-상속" class="headerlink" title="직접 상속"></a>직접 상속</h2><h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h3><p>Object.create 메서드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성하며 다른 객체 생성 방식과 마찬가지로 추상 연산 <code>OrdinaryObjectCreate</code> 를 호출한다.</p>
<ul>
<li>첫 번째 매개변수: 생성할 객체의 프로토타입으로 지정할 객체</li>
<li>두 번째 매개변수: 생성할 객체의 프로퍼티 키와 프로퍼티 디스크립터 객체</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype, &#123;</span><br><span class="line">  x: &#123; <span class="attr">value</span>: <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>이처럼 Object.create 메서드는 첫 번째 매개변수에 전달한 객체의 프로토타입 체인에 속하는 객체를 생성하는데, 객체를 생성하면서 직접적으로 상속을 구현하는 것이다. 장점은 다음과 같다.</p>
<ul>
<li>new 연산자없이 객체 생성</li>
<li>프로토타입을 지정하면서 객체 생성</li>
<li>객체 리터럴에 의해 생성된 객체도 상속 가능</li>
</ul>
<p>Object.prototype의 빌트인 메서드를 객체가 직접 호출하는 것을 권장하지 않는데, 그 이유는 Object.create 메서드를 통해 프로토타입 체인의 종점에 위치하는 객체를 생성할 수 있기 때문이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj) === <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">// TypeError: obj.hasOwnProperty is not a function</span></span><br></pre></td></tr></table></figure>

<p>따라서 이 같은 에러를 발생시킬 위험을 없애기 위해 Object.prototype의 빌트인 메서드는 다음과 같이 간접적으로 호출하는 것이 좋다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.hasOwnProperty.call(obj, <span class="string">&#x27;a&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="객체-리터럴-내부에서-proto-에-의한-직접-상속"><a href="#객체-리터럴-내부에서-proto-에-의한-직접-상속" class="headerlink" title="객체 리터럴 내부에서 __proto__ 에 의한 직접 상속"></a>객체 리터럴 내부에서 <code>__proto__</code> 에 의한 직접 상속</h3><p>Object.create 메서드에 의한 직접 상속은 앞에서 다룬 것과 같이 여러 장점이 있지만 두 번째 인자로 프로퍼티를 정의하는 것은 번거롭다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myProto = &#123; <span class="attr">x</span>: <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체 리터럴에 의해 객체를 생성하면서 프로토타입을 지정하여 직접 상속</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  y: <span class="number">20</span>,</span><br><span class="line">  __proto__: myProto, <span class="comment">// obj → myProto → Object.prototype → null</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.x, obj.y); <span class="comment">// 10 20</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj) === myProto); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="정적-프로퍼티와-메서드"><a href="#정적-프로퍼티와-메서드" class="headerlink" title="정적 프로퍼티와 메서드"></a>정적 프로퍼티와 메서드</h3><p>정적(static) 프로퍼티 및 메서드는 생성자 함수로 인스턴스를 생성하지 않아도 참조,호출할 수 있는 프로퍼티 및 메서드를 말한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Hi! My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 정적 프로퍼티</span></span><br><span class="line">Person.staticProp = <span class="string">&#x27;static prop&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 정적 메서드</span></span><br><span class="line">Person.staticMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;staticMethod&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line"></span><br><span class="line">Person.staticMethod(); <span class="comment">// staticMethod</span></span><br><span class="line">me.staticMethod(); <span class="comment">// TypeError: me.staticMethod is not a function</span></span><br></pre></td></tr></table></figure>

<p>정적 프로퍼티/메서드는 생성자 함수가 생성한 인스턴스로 참조/호출할 수 없다. 인스턴스로 참조/호출할 수 있는 프로퍼티/메서드는 프로토타입 체인 상에 존재해야 한다. 프로토타입 메서드를 호출하려면 인스턴스를 생성해야 하지만 정적 메서드는 인스턴스를 생성하지 않아도 호출할 수 있다.</p>
<p>만약 인스턴스/프로토타입 메서드 내에서 this를 사용하지 않는다면 그 메서드는 정적 메서드로 변경할 수 있다.</p>
<h2 id="프로퍼티-존재-확인"><a href="#프로퍼티-존재-확인" class="headerlink" title="프로퍼티 존재 확인"></a>프로퍼티 존재 확인</h2><h3 id="in-연산자"><a href="#in-연산자" class="headerlink" title="in 연산자"></a>in 연산자</h3><p>in 연산자는 객체 내에 특정 프로퍼티가 존재하는지 여부를 확인한다. 이는 파이썬의 in 연산자와 비슷하게 동작한다. 하지만 해당 객체의 프로퍼티뿐만 아니라 대상 객체가 상속받은 모든 프로토타입의 프로퍼티를 확인하므로 주의가 필요하다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;hasOwnProperty&#x27;</span> <span class="keyword">in</span> a); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-prototype-hasOwnProperty-메서드"><a href="#Object-prototype-hasOwnProperty-메서드" class="headerlink" title="Object.prototype.hasOwnProperty 메서드"></a>Object.prototype.hasOwnProperty 메서드</h3><p><code>Object.prototype.hasOwnProperty</code> 객체에 특정 프로퍼티가 존재하는지 확인할 수 있다. 프로퍼티 키가 객체 고유의 프로퍼티 키인 경우에만 true를 반환한다는 점에서 in 연산자와 차이가 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;lee&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person.hasOwnProperty(<span class="string">&#x27;age&#x27;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="프로퍼티-열거"><a href="#프로퍼티-열거" class="headerlink" title="프로퍼티 열거"></a>프로퍼티 열거</h2><h3 id="for-…-in"><a href="#for-…-in" class="headerlink" title="for … in"></a>for … in</h3><p>객체의 모든 프로퍼티를 순회하며 열거(enumeration)하려면 <code>for ... in</code> 문을 사용한다. <code>for ... in</code> 문은 객체의 프로퍼티 개수만큼 순회하며 <code>for ... in</code> 문의 변수 선언문에서 선언한 변수에 프로퍼티 키를 할당한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  address: <span class="string">&#x27;Seoul&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&#x27;: &#x27;</span> + person[key]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name: Lee</span></span><br><span class="line"><span class="comment">// address: Seoul</span></span><br></pre></td></tr></table></figure>

<p>그리고 주의해야 할 점은, <code>for ... in</code> 문은 in 연산자처럼 순회 대상 객체의 프로퍼티 뿐만 아니라 상속받은 프로토타입의 프로퍼티까지 열거한다는 점이다. 하지만 위 예제의 경우, toString과 같은 <code>Object.prototype</code> 의 프로퍼티가 열거되지 않는다.</p>
<p>그 이유는 <code>toString</code> 메서드가 열거할 수 없도록 정의되어 있는 프로퍼티이기 때문이다. 즉, 프로퍼티의 프로퍼티 어트리뷰트 <code>[[Enumerable]]</code> 의 값이 <code>false</code> 이기 때문이다.</p>
<p>그리고 <code>for ... in</code>프로퍼티 키가 심벌인 프로퍼티는 열거하지 않는다.</p>
<h3 id="Object-keys-values-entries"><a href="#Object-keys-values-entries" class="headerlink" title="Object.(keys | values | entries)"></a>Object.(keys | values | entries)</h3><p>Object.keys 메서드는 객체 자신의 열거 가능한(enumerable) 프로퍼티 키를 배열로 반환한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  address: <span class="string">&#x27;Seoul&#x27;</span>,</span><br><span class="line">  __proto__: &#123; <span class="attr">age</span>: <span class="number">20</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(person)); <span class="comment">// [&quot;name&quot;, &quot;address&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(person)); <span class="comment">// [&quot;Lee&quot;, &quot;Seoul&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(person)); <span class="comment">// [[&quot;name&quot;, &quot;Lee&quot;], [&quot;address&quot;, &quot;Seoul&quot;]]</span></span><br></pre></td></tr></table></figure>

<p>Object.values 와 Object.entries 는 ES8 에서 도입된 메서드이다.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dooyeong20.github.io/2021/05/22/javascript/day16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my.png">
      <meta itemprop="name" content="dooyeong">
      <meta itemprop="description" content="좋은 개발자 기술 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="두영's 지식 공간">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/22/javascript/day16/" class="post-title-link" itemprop="url">JavaScript 16 - Prototype (1)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">작성일</span>
      

      <time title="Post created: 2021-05-22 12:12:06 / Updated at: 13:48:02" itemprop="dateCreated datePublished" datetime="2021-05-22T12:12:06+09:00">2021-05-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="자바스크립트-프로토타입"><a href="#자바스크립트-프로토타입" class="headerlink" title="자바스크립트 프로토타입"></a>자바스크립트 프로토타입</h1><p>자바스크립트는 명령령, 함수형, 프로토타입 그리고 객체지향 기반의 프로그래밍을 지원하는 <strong>멀티 패러타임</strong> 프로그래밍 언어이다.</p>
<p>자바스크립트는 Java 의 public, private, 상속 등이 없어서 객체지향이 아니라고 오해를 받지만, 이러한 클래스 기반 객체지향이 아닌 프로토타입 기반의 강력한 객체지향 프로그래밍이 가능한 언어이다.</p>
<h2 id="클래스"><a href="#클래스" class="headerlink" title="클래스"></a>클래스</h2><p>자바스크립트에도 ES6 에서 클래스가 도입되었는데, 기존의 프로토타입 기반의 객체지향 패러다임에서 아예 전환된 것이 아니라, 새로운 객체 생성 메커니즘이 하나 추가된 것이라고 볼 수 있다.</p>
<p>자바스크립트는 객체 기반의 프로그래밍 언어이고, 몇몇 원시타입을 제외하고는 모든 것이 객체이다. 함수, 배열, 정규표현식 등도 물론 객체이다.</p>
<h2 id="객체지향-프로그래밍"><a href="#객체지향-프로그래밍" class="headerlink" title="객체지향 프로그래밍"></a>객체지향 프로그래밍</h2><p>객체지향 프로그래밍(OOP) 란 프로그램을 명령어 뭉치, 함수 목록으로 취급하는 기존의 명령형 프로그래밍의 절차지향적 관점에서 탈피해 여러 개의 사물, 즉 객체의 집합으로 프로그램을 표현하는 패러다임이다.</p>
<p>객체지향은 실제 세계의 사물들을 프로그래밍 언어의 패러다임으로 표현하기 위해서 property와 attribute 등으로 표현하는 것이다. 그리고 이러한 객체들의 속성들 중에서 개발에 필요한 속성만 간추려서 사용할 수 있도록 추상화하는 과정을 거친다.</p>
<p>아래는 person 이라는 간단한 객체를 자바스크립트 문법으로 표현한 것이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;lee&#x27;</span>,</span><br><span class="line">  address: <span class="string">&#x27;seoul&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">talk</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> : hello !`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person);</span><br></pre></td></tr></table></figure>

<p>name과 address는 상태를 나타내는 데이터이며 talk는 동작(메서드)이다.</p>
<p>이렇듯 객체지향 프로그래밍은 상태와 동작을 하나의 단위로 묶어서 객체라는 단위를 가지고 프로그래밍을 하는 것이다. 그리고 이러한 객체들 사이에 서로 관계성을 가지며 서로 통신작용을 할 수 있는 것이다.</p>
<h2 id="상속과-프로토타입"><a href="#상속과-프로토타입" class="headerlink" title="상속과 프로토타입"></a>상속과 프로토타입</h2><p>상속은 객체지향의 핵심 개념이다. 어떠한 객체의 상태(프로퍼티)나 동작(메서드)을 그대로 물려받아 사용할 수 있는 것이다.</p>
<p>자바스크립트에서는 <strong>프로토타입</strong> 이라는 것을 기반으로 상속을 구현해 중복을 제거한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.radius = radius;</span><br><span class="line">  <span class="built_in">this</span>.getArea = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.PI * <span class="built_in">this</span>.radius ** <span class="number">2</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> Circle(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>예를 들어서 위의 Circle 이라는 생성자 함수로부터 아래 circle1과 circle2를 만들었다고 생각해보자. 그러면 getArea 라는 메서드는 각각 Circle의 인스턴스를 생성할 때마다 생성이 된다. 이렇게 되면 각각의 인스턴스들이 동일한 동작을 하는 함수를 각자 중복적으로 소유하고 있는 것인데 이는 메모리 비용상으로 합리적이지 않고 하나만 생성해내 모든 인스턴스가 공유해서 사용하는 것이 옳아보인다.</p>
<p>이 때 자바스크립트의 프로토타입 개념을 도입해 상속을 구현함으로써 중복을 제거해보겠다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Circle.prototype.getArea = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.PI * <span class="built_in">this</span>.radius ** <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> Circle(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>위의 <code>Circle.prototype.getArea</code> 에 함수를 할당해줌으로써 <code>Circle</code> 의 프로토타입에 함수를 할당해주는 것이다. 이렇게 되면 이제부터 Circle 생성자 함수를 통해 만든 인스턴스는 getArea를 공통적으로 소유(공유)할 수 있는 것이다.</p>
<h2 id="프로토타입-객체"><a href="#프로토타입-객체" class="headerlink" title="프로토타입 객체"></a>프로토타입 객체</h2><p>프로토타입은 객체이며, 객체지향 프로그래밍에서 중요한 개념인 <strong>상속</strong>을 구현하기 위해서 사용된다. 프로토타입이란, 한 객체의 부모 역할을 하는 객체로서 다른 객체들 사이의 공유 프로퍼티(메서드 포함)를 제공한다.</p>
<p>모든 객체는 <code>[[Prototype]]</code> 이라는 ‘내부 슬롯’ 을 가지며 이 내부 슬록의 값은 프로토타입의 참조이다. 객체가 생성될 때 객체 생성 방식에 따라서 프로토타입이 결정되어 <code>[[Prototype]]</code> 에 저장되는 것이다.</p>
<p><code>[[Prototype]]</code> 내부 슬록에는 직접 접근할 수 없지만, <code>__proto__</code> 접근자 프로퍼티를 통해서 자신의 프로토타입, 즉 <code>[[Prototype]]</code> 애 저장되어 있는 프로토타입 참조에 간접적으로 접근할 수 있다. 그리고 <code>생성자함수.prototype</code> 은 자신의 constructor 프로퍼티를 통해서 생성자 함수에 접근할 수 있고, 생성자 함수는 반대로 자신의 prototype 프로퍼티를 통해 프로토타입에 접근할 수 있게 되는 것이다.</p>
<h3 id="proto-접근자-프로퍼티"><a href="#proto-접근자-프로퍼티" class="headerlink" title="__proto__ 접근자 프로퍼티"></a><code>__proto__</code> 접근자 프로퍼티</h3><p>모든 객체는 <code>__proto__</code> 를 통해서 자신의 프로토타입에 간접적으로 접근할 수 있게 된다.</p>
<p>이 때 <code>__proto__</code> 는 접근자 프로퍼티라는 것이 중요하다. 내부 슬롯은 프로퍼티가 아니기 때문에, 내부 슬롯 및 내부 메서드에 직접 접근 및 호출할 수 있는 기능을 제공하지 않는다. 따라서 간접적으로 접근할 수 있도록 <code>__proto__</code> 를 제공하는 것이다.</p>
<p>그리고 <code>__proto__</code> 접근자 프로퍼티는 상속을 통해서 사용된다. <code>__proto__</code> 접근자 프로퍼티는 객체가 직접적으로 소유하는 프로퍼티가 아니라 <code>Object.prototype</code>의 프로퍼티이다.</p>
<blockquote>
<p><strong>Object.prototype</strong></p>
<p>모든 객체는 프로토타입의 계층 구조인 프로토타입 체인에 묶여 있다. 자바스크립트 엔진은 객체의 프로퍼티(메서드 포함)에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 <strong>proto</strong> 접근자 프로퍼티가 가리키는 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 프로토타입 체인의 종점, 즉 프로토타입 체인의 최상위 객체는 Object.prototype이며, 이 객체의 프로퍼티와 메서드는 모든 객체에게 상속된다.</p>
</blockquote>
<p>코드 내에서 <code>__proto__</code> 를 직접 사용하는 것을 좋지 않다. 왜냐하면 <code>Object.create(null)</code> 과 같이 프로토타입 체인의 종점인 객체를 생성하면 <code>__proto__</code> 를 상속받을 수 없기 때문이다.</p>
<p><code>__proto__</code> 접근자 프로퍼티 대신 프로토타입의 참조를 취득하고 싶은 경우에는 Object.getPrototypeOf 메서드를 사용하고, 프로토타입을 교체하고 싶은 경우에는 <code>Object.setPrototypeOf</code> 메서드를 사용하면 된다.</p>
<h3 id="함수-객체의-prototype-프로퍼티"><a href="#함수-객체의-prototype-프로퍼티" class="headerlink" title="함수 객체의 prototype (프로퍼티)"></a>함수 객체의 prototype (프로퍼티)</h3><p>prototype 이라는 말이 너무 자주 출몰해서 헷갈릴 수 있기 때문에 개념 정립을 확실히 해두어야 한다. ‘prototype 프로퍼티’ 는 함수 객체만이 소유할 수 있고, 이는 생성자 함수가 생성하는 인스턴스의 프로토타입을 가리킨다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;.hasOwnProperty(<span class="string">&#x27;prototype&#x27;</span>)); <span class="comment">// -&gt; true</span></span><br><span class="line"></span><br><span class="line">(&#123;&#125;.hasOwnProperty(<span class="string">&#x27;prototype&#x27;</span>)); <span class="comment">// -&gt; false</span></span><br></pre></td></tr></table></figure>

<p>설명에서처럼, ‘생성자’ 함수가 가질 수 있는 것이기 때문에 arrow function 이나 ES6 메서드 축약 표현으로 정의한 메서드는 prototype 프로퍼티를 가질 수 없는 것이다.</p>
<p>모든 객체가 가지고 있는 <code>__proto__</code> 접근자 프로퍼티와 함수 객체만이 가지고 있는 prototype 프로퍼티는 결국 동일한 프로토타입을 가리킨다. 하지만 이들 프로퍼티를 사용하는 주체가 다르다.</p>
<ul>
<li><p><code>__proto__</code> 접근자 프로퍼티</p>
<ul>
<li>소유: 모든 객체</li>
<li>값: 프로토타입 참조</li>
<li>사용 주체: 모든 객체</li>
<li>사용 목적: 객체가 자신의 프로토타입에 접근 &amp; 교체하기 위해</li>
</ul>
</li>
<li><p><code>prototype</code> 프로퍼티</p>
<ul>
<li>소유: 생성자 함수(constructor)</li>
<li>값: 프로토타입 참조</li>
<li>사용 주체: 생성자 함수</li>
<li>자신이 생성할 객체(인스턴스)의 프로토타입을 할당하기 위해 사용</li>
</ul>
</li>
</ul>
<p>이 차이에 대한 내용은 매우 헷갈릴 수 있다. 아래 예시를 보자.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person.prototype과 me.__proto__는 결국 동일한 프로토타입을 가리킨다.</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype === me.__proto__); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="프로토타입의-constructor-프로퍼티와-생성자-함수"><a href="#프로토타입의-constructor-프로퍼티와-생성자-함수" class="headerlink" title="프로토타입의 constructor 프로퍼티와 생성자 함수"></a>프로토타입의 constructor 프로퍼티와 생성자 함수</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(me.constructor === Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>위 예제에서 Person 생성자 함수는 me 객체를 생성했다. 이때 me 객체는 프로토타입의 constructor 프로퍼티를 통해 생성자 함수와 연결된다. me 객체에는 constructor 프로퍼티가 없지만 me 객체의 프로토타입인 Person.prototye에는 constructor 프로퍼티가 있다. 따라서 me 객체는 프로토타입인 Person.prototye의 constructor 프로퍼티를 상속받아 사용할 수 있다.</p>
<h2 id="리터럴로-생성한-객체의-생성자-함수와-프로토타입"><a href="#리터럴로-생성한-객체의-생성자-함수와-프로토타입" class="headerlink" title="리터럴로 생성한 객체의 생성자 함수와 프로토타입"></a>리터럴로 생성한 객체의 생성자 함수와 프로토타입</h2><p>앞서서 살펴본대로, 생성자 함수로 생성된 객체(인스턴스)는 프로토타입의 constructor 프로퍼티로 자신의 생성자 함수를 참조할 수 있다.</p>
<p>하지만, 생성자 함수가 없는 리터럴 객체 생성 방식의 경우에는 어떨까?</p>
<p>리터럴로 생성한 객체도 당연하게도 프로토타입이 존재한다. 하지만 이 경우에는 constructor가 가리키는 생성자 함수가 자신을 생성한 생성자 함수인 것을 보장하지 않는다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.constructor === <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function 생성자 함수로 생성한 함수 객체가 아니라 함수 선언문으로 생성했다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo의 생성자 함수는 Function 생성자 함수라고 판단하고 있다.</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.constructor === <span class="built_in">Function</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>위 의 객체들은 생성자 함수로 생성한 객체가 아닌데도 Object, Function 객체를 생성자 함수로써 참조하고 있다.</p>
<p>리터럴 표기법에 의해 생성된 객체도 상속을 위해 프로토타입이 필요하기 때문에 리터럴 표기법에 의해 생성된 객체도 가상적인 생성자 함수를 가지기 때문에 이러한 현상이 발생하는 것이다.</p>
<p>프로토타입은 생성자 함수와 더불어 생성되며 prototype, constructor 프로퍼티에 의해 연결되어 있기 때문이다. 즉, 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍(pair)으로 존재한다.</p>
<p>리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입은 다음과 같다.</p>
<ul>
<li><p>객체 리터럴</p>
<ul>
<li>생성자 함수: Object</li>
<li>프로토타입: Object.prototype</li>
</ul>
</li>
<li><p>함수 리터럴</p>
<ul>
<li>생성자 함수: Function</li>
<li>프로토타입: Function.prototype</li>
</ul>
</li>
<li><p>배열 리터럴</p>
<ul>
<li>생성자 함수: Array</li>
<li>프로토타입: Array.prototype</li>
</ul>
</li>
<li><p>정규 표현식 리터럴</p>
<ul>
<li>생성자 함수: RegExp</li>
<li>프로토타입: RegExp.prototype</li>
</ul>
</li>
</ul>
<h2 id="프로토타입-생성-시점"><a href="#프로토타입-생성-시점" class="headerlink" title="프로토타입 생성 시점"></a>프로토타입 생성 시점</h2><p>모든 객체는 결국 생성자 함수와 연결되어 있다는 사실을 알 수 있다. 그럼 프로토타입은 언제 생성될까?</p>
<p>프로토타입은 생성자 함수가 생성되는 시점에 함께 생성된다. 프로토타입과 생성자 함수는 항상 쌍으로 존재하기 때문이다.</p>
<h3 id="사용자-정의-생성자-함수"><a href="#사용자-정의-생성자-함수" class="headerlink" title="사용자 정의 생성자 함수"></a>사용자 정의 생성자 함수</h3><p>내부 메서드 <code>[[Construct]]</code> 를 가지는 함수 객체는 new 연산자로 생성자 함수로써 호출할 수 있다. 이러한 constructor 함수는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 함께 prototype 이 생성된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 평가되어 함수 객체 Person 이 생성될 때 prototype 도 함께 생성</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arrow function은 non-constructor 이기 때문에 prototype이 생성되지 않음</span></span><br><span class="line"><span class="keyword">const</span> Person2 = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>참고로 이 때 생성된 프로토타입의 프로토타입은 Object.prototype 이 된다.</p>
<h3 id="빌트인-생성자-함수"><a href="#빌트인-생성자-함수" class="headerlink" title="빌트인 생성자 함수"></a>빌트인 생성자 함수</h3><p>Object, String, Number, Function, Array, RegExp, Date, Promise 같은 빌트인 생성자 함수도 생성자 함수가 생성되는 시점에 프로토타입이 생성된다. 그리고 모든 빌트인 생성자 함수는 전역 객체(window 등)가 생성될 때 생성된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// browser</span></span><br><span class="line"><span class="built_in">window</span>.Object === <span class="built_in">Object</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>이처럼 생성자 함수와 프로토타입은 이미 객체화되어 존재한다. 이후 생성자 함수 또는 리터럴 표기법으로 객체를 생성하면 프로토타입은 생성된 객체의 <code>[[Prototype]]</code> 내부 슬롯에 할당된다.</p>
<h2 id="프로토타입-체인"><a href="#프로토타입-체인" class="headerlink" title="프로토타입 체인"></a>프로토타입 체인</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Hi! My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(me.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>이 때, me 객체는 자신을 생성한 함수인 Person의 prototype을 상속받았기 때문에 sayHello 라는 메서드를 사용할 수 있게 된 것이고, Person의 prototype이 Object의 prototype을 상속받았기 때문 hasOwnProperty 메서드도 사용할 수있는 것이다. 즉, 스코프를 배웠을 때와 마찬가지로 프로토타입도 프로토타입 체인을 타고 검색한다는 것을 의미한다.</p>
<p>즉, 자바스크립트는 객체의 프로퍼티(메서드 포함)에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 <code>[[Prototype]]</code> 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 이를 프로토타입 체인이라 하는 것이다. 프로토타입 체인은 자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 메커니즘이다.</p>
<p>프로토타입 체인의 최상위에 위치하는 객체는 언제나 <code>Object.prototype</code> 이다. 즉, bject.prototype을 프로토타입 체인의 종점(end of prototype chain)이라 한다.</p>
<p>Object.prototype의 프로토타입, 즉 <code>[[Prototype]]</code> 내부 슬롯의 값은 null이다.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dooyeong20.github.io/2021/05/21/javascript/day15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my.png">
      <meta itemprop="name" content="dooyeong">
      <meta itemprop="description" content="좋은 개발자 기술 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="두영's 지식 공간">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/21/javascript/day15/" class="post-title-link" itemprop="url">JavaScript 15 - 일급 객체</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">작성일</span>
      

      <time title="Post created: 2021-05-21 16:42:06 / Updated at: 17:13:45" itemprop="dateCreated datePublished" datetime="2021-05-21T16:42:06+09:00">2021-05-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="함수와-일급-객체"><a href="#함수와-일급-객체" class="headerlink" title="함수와 일급 객체"></a>함수와 일급 객체</h1><h2 id="일급-객체"><a href="#일급-객체" class="headerlink" title="일급 객체"></a>일급 객체</h2><p>일급 객체란,</p>
<ul>
<li>무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.</li>
<li>변수나 자료구조(객체, 배열 등)에 저장할 수 있다.</li>
<li>함수의 매개변수에게 전달할 수 있다.</li>
<li>함수의 반환값으로 사용할 수 있다.</li>
</ul>
<p>라는 조건을 만족하는 객체이다. 자바스크립트에서는 함수는 위 조건들을 만족하기 때문에 일급 객체인 것이다.</p>
<p>즉, 함수를 일반적인 객체와 동일하게 사용할 수 있다는 것이다. 값으로써 사용할 수 있기 때문에 인수로 넘길 수 있고, 변수에 할당할 수 있고, 함수의 리턴 값으로 반환할 수도 있다.</p>
<h2 id="함수-객체의-프로퍼티"><a href="#함수-객체의-프로퍼티" class="headerlink" title="함수 객체의 프로퍼티"></a>함수 객체의 프로퍼티</h2><p>함수는 객체이기 때문에, 아래와 같이 프로퍼티를 가질 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">arguments</span>: <span class="literal">null</span></span><br><span class="line">caller: <span class="literal">null</span></span><br><span class="line">length: <span class="number">0</span></span><br><span class="line">name: <span class="string">&quot;a&quot;</span></span><br><span class="line">prototype: &#123;<span class="attr">constructor</span>: ƒ&#125;</span><br><span class="line">__proto__: ƒ ()</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><p>함수 객체 프로퍼티 중 <code>arguments</code> 프로퍼티는 함수를 호출할 때 넘겨진 인수들을 담고 있는 유사 배열 객체이다.</p>
<p>함수의 매개변수보다 더 많은 인수가 넘어오더라도 이를 무시하지 않고, <code>arguments</code> 에 차곡차곡 저장해놓는 것이다.</p>
<p>참고로, 이와 비슷한 역할을 수행하는 Rest 파라미터라는 것도 있으며 사용법은 아래와 같다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br></pre></td></tr></table></figure>

<p><code>arguments</code> 는 유사 배열 객체이지만, <code>args</code> 같은 경우에는 배열이다. 따라서 <code>args</code> 를 가지고 <code>map</code>, <code>filter</code> 등의 배열 전용 고차함수를 사용할 수 있다.</p>
<h3 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h3><p><code>caller</code> 는 비표준 프로퍼티이고, 자신의 함수 자신을 호출한 함수를 가리킨다. 많이 사용되지 않으므로 코드를 읽을 수 있을 정도로만 참고해두면 될 것 같다.</p>
<h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><p>함수의 <code>length</code> 프로퍼티는 함수 정의시 선언한 매개변수의 개수이다. <code>arguments</code> 의 <code>length</code> 와 헷갈리면 안되는 것이, 함수의 <code>length</code> 객체는 매개변수의 개수이고, <code>arguments</code> 의 <code>length</code> 객체는 전달되는 인수의 개수이기 때문이다.</p>
<h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><p><code>name</code> 은 함수의 이름을 나타낸다. 정식 표준이 되긴했지만, 사실 쓸 일이 많지 않다.</p>
<p>참고로 <code>name</code> 프로퍼티는 ES5, ES6 에서 각자 동작을 달리하기 때문에 주의해야 한다.</p>
<h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h3><p>함수도 마찬가지로 prototype 을 가지며, 다른 객체와 마찬가지로 <code>foo.prototype</code> 로 접근할 수 있다.</p>
<p>이 <code>prototype</code> 은 함수 객체만 가지고 있는데, <code>__proto__</code> 의 경우에도 브라우저에서 <code>console.dir</code> 로 확인할 수 있는데 이는 사용자가 확인하기 쉽도록 표현해준 것이다.</p>
<h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p><code>prototype</code> 프로퍼티는 <code>new</code> 를 통해서 생성자 함수를 호출할 수 있는 함수 객체인 construcor 가 소유한 프로퍼티이다.</p>
<p>non-constructor 객체는 prototype 이 없다.</p>
<p><code>prototype</code> 은 함수가 객체를 생성할 때(new 로 호출되었을 때) 생성할 인스턴스의 프로토타입 객체를 가리키는 역할을 한다.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dooyeong20.github.io/2021/05/20/ps/boj-10942/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my.png">
      <meta itemprop="name" content="dooyeong">
      <meta itemprop="description" content="좋은 개발자 기술 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="두영's 지식 공간">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/20/ps/boj-10942/" class="post-title-link" itemprop="url">BOJ 10942 - 팰린드롬?</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">작성일</span>
      

      <time title="Post created: 2021-05-20 21:00:23 / Updated at: 21:05:50" itemprop="dateCreated datePublished" datetime="2021-05-20T21:00:23+09:00">2021-05-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Problem-Solving/" itemprop="url" rel="index"><span itemprop="name">Problem Solving</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Problem-Solving/BOJ/" itemprop="url" rel="index"><span itemprop="name">BOJ</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Problem-Solving-팰린드롬-G3"><a href="#Problem-Solving-팰린드롬-G3" class="headerlink" title="Problem Solving - 팰린드롬? (G3)"></a>Problem Solving - 팰린드롬? (G3)</h1><p><a target="_blank" rel="noopener" href="https://www.acmicpc.net/problem/10942">여기서</a> 풀어볼 수 있습니다.</p>
<h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><p>명우는 홍준이와 함께 팰린드롬 놀이를 해보려고 한다.</p>
<p>먼저, 홍준이는 자연수 N개를 칠판에 적는다. 그 다음, 명우에게 질문을 총 M번 한다.</p>
<p>각 질문은 두 정수 S와 E(1 ≤ S ≤ E ≤ N)로 나타낼 수 있으며, S번째 수부터 E번째 까지 수가 팰린드롬을 이루는지를 물어보며, 명우는 각 질문에 대해 팰린드롬이다 또는 아니다를 말해야 한다.</p>
<p>예를 들어, 홍준이가 칠판에 적은 수가 1, 2, 1, 3, 1, 2, 1라고 하자.</p>
<p>S = 1, E = 3인 경우 1, 2, 1은 팰린드롬이다.<br>S = 2, E = 5인 경우 2, 1, 3, 1은 팰린드롬이 아니다.<br>S = 3, E = 3인 경우 1은 팰린드롬이다.<br>S = 5, E = 7인 경우 1, 2, 1은 팰린드롬이다.<br>자연수 N개와 질문 M개가 모두 주어졌을 때, 명우의 대답을 구하는 프로그램을 작성하시오.</p>
<h2 id="예제-입-출력"><a href="#예제-입-출력" class="headerlink" title="예제 입/출력"></a>예제 입/출력</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">입력</span><br><span class="line"></span><br><span class="line">7</span><br><span class="line">1 2 1 3 1 2 1</span><br><span class="line">4</span><br><span class="line">1 3</span><br><span class="line">2 5</span><br><span class="line">3 3</span><br><span class="line">5 7</span><br><span class="line"></span><br><span class="line">출력</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><p>팰린드롬을 구할 때 각 질문당(M) 각각 팰린드롬인지 아닌지 구해주게 되면 O(N^3) (N=2000) 이 걸리기 때문에 0.5초라는 제한시간 내에 절대 풀수 없다. 따라서 메모이제이션을 통해 이미 구한 값을 재활용 해주는 방식으로 빠르게 정답을 구해주는 것이 이 문제의 핵심이었다.</p>
<p>원래는 bottom-up dp가 편하지만, 이번 문제에서는 재귀적인 풀이 방법이 가장 먼저 떠올라 top-down 메모이제이션으로 문제를 풀이했다.</p>
<p>팰린 드롬을 체크해줄 때, 시작 숫자와 끝 숫자가 다르다면 무조건 0을 리턴해주었고 만약 같다면 그 안의 내용인 (시작숫자 + 1) ~ (끝 숫자 - 1)이 팰린드롬 수인지 재귀적으로 호출하여 구해주며 메모를 해주었다. 그리고 메모리 초과가 계속 떠서 depth 가 2 일 때 까지는 메모이제이션을 사용해주지 않고 리턴해주었다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> stdin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pal</span>(<span class="params">nums, dp, s, e</span>):</span></span><br><span class="line">    <span class="keyword">if</span> (s, e) <span class="keyword">in</span> dp:</span><br><span class="line">        <span class="keyword">return</span> dp[(s, e)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s == e:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> nums[s-<span class="number">1</span>] != nums[e-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> e - s == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s + <span class="number">1</span> &lt;= e - <span class="number">1</span>:</span><br><span class="line">        dp[(s, e)] = pal(nums, dp, s+<span class="number">1</span>, e-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[(s, e)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">N = <span class="built_in">int</span>(stdin.readline())</span><br><span class="line">nums = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, stdin.readline().split()))</span><br><span class="line">M = <span class="built_in">int</span>(stdin.readline())</span><br><span class="line">dp = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">    s, e = <span class="built_in">map</span>(<span class="built_in">int</span>, stdin.readline().split())</span><br><span class="line">    <span class="built_in">print</span>(pal(nums, dp, s, e))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>구현은 어렵지 않았지만, 이 문제가 dp 로 풀어야하는 문제면서 어떻게 dp로 풀 수 있을지 생각해내는 것이 어려운 문제였다.<br>양 끝을 비교해주고 그 값이 같다면 양 끝을 제외한 값이 팰린드롬인지 확인해주는 로직을 생각해냈다면 그 이후 구현은 단순 재귀이기 때문에 그렇게 어려운 문제는 아니라고 생각한다.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dooyeong20.github.io/2021/05/20/ps/leetcode_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my.png">
      <meta itemprop="name" content="dooyeong">
      <meta itemprop="description" content="좋은 개발자 기술 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="두영's 지식 공간">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/20/ps/leetcode_/" class="post-title-link" itemprop="url">leetcode 150. Evaluate Reverse Polish Notation</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">작성일</span>

      <time title="Post created: 2021-05-20 19:35:23" itemprop="dateCreated datePublished" datetime="2021-05-20T19:35:23+09:00">2021-05-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Updated at: 2021-05-25 21:15:50" itemprop="dateModified" datetime="2021-05-25T21:15:50+09:00">2021-05-25</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Problem-Solving/" itemprop="url" rel="index"><span itemprop="name">Problem Solving</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Problem-Solving/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="150-Evaluate-Reverse-Polish-Notation"><a href="#150-Evaluate-Reverse-Polish-Notation" class="headerlink" title="150. Evaluate Reverse Polish Notation"></a>150. Evaluate Reverse Polish Notation</h1><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/evaluate-reverse-polish-notation/">여기서</a> 문제를 풀어볼 수 있습니다.</li>
</ul>
<h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p>
<p>Valid operators are <code>+, -, *, /</code> Each operand may be an integer or another expression.</p>
<p>Note that division between two integers should truncate toward zero.</p>
<p>It is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: tokens &#x3D; [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span><br><span class="line">Output: 9</span><br><span class="line">Explanation: ((2 + 1) * 3) &#x3D; 9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: tokens &#x3D; [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;&#x2F;&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]</span><br><span class="line">Output: 22</span><br><span class="line">Explanation: ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5</span><br><span class="line">&#x3D; ((10 * 0) + 17) + 5</span><br><span class="line">&#x3D; (0 + 17) + 5</span><br><span class="line">&#x3D; 17 + 5</span><br><span class="line">&#x3D; 22</span><br></pre></td></tr></table></figure>

<h2 id="문제-풀이"><a href="#문제-풀이" class="headerlink" title="문제 풀이"></a>문제 풀이</h2><p>이 문제는 유명한 스택 문제인 후위 표기법 문제였다. 각각의 token 들을 순회하며, 연산자가 아니라면(숫자라면) 스택에 넣고 만약 연산자라면 스택 상위 2개를 연산한다음 다시 스택에 넣어주는 방식으로 연산을 하면 마지막에 스택에 단 하나의 수가 남게 된다. 따라서 그 수를 pop 해서 출력해주면 되는 쉬운 문제였다.</p>
<p>이번 문제는 leetcode의 daily challenge 치고는 많이 쉬운 편이었던 것같다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">cal</span>(<span class="params">b, a, op</span>):</span></span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> a - b</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> a * b</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">int</span>(a / b)</span><br><span class="line"></span><br><span class="line">        s = []</span><br><span class="line">        op = <span class="built_in">set</span>(<span class="string">&#x27;+-/*&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> t <span class="keyword">in</span> op:</span><br><span class="line">                s.append(cal(s.pop(), s.pop(), t))</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            s.append(<span class="built_in">int</span>(t))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.pop()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dooyeong20.github.io/2021/05/20/ps/leetcode_102/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my.png">
      <meta itemprop="name" content="dooyeong">
      <meta itemprop="description" content="좋은 개발자 기술 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="두영's 지식 공간">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/20/ps/leetcode_102/" class="post-title-link" itemprop="url">leetcode 102. Binary Tree Level Order Traversal</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">작성일</span>
      

      <time title="Post created: 2021-05-20 19:35:23 / Updated at: 19:40:58" itemprop="dateCreated datePublished" datetime="2021-05-20T19:35:23+09:00">2021-05-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Problem-Solving/" itemprop="url" rel="index"><span itemprop="name">Problem Solving</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Problem-Solving/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a>102. Binary Tree Level Order Traversal</h1><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-level-order-traversal/">여기서</a> 문제를 풀어볼 수 있습니다.</li>
</ul>
<h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><p>Given the root of a binary tree, return the level order traversal of its nodes’ values. (i.e., from left to right, level by level).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">Output: [[3],[9,20],[15,7]]</span><br></pre></td></tr></table></figure>

<img src="/images/leet_102.png" width='400'>

<h2 id="문제-풀이"><a href="#문제-풀이" class="headerlink" title="문제 풀이"></a>문제 풀이</h2><p>아주 단순한… bfs 문제이다. 각 노드의 레벨들을 순회하면서 각 레벨을 마킹해주어, <code>ans</code> 의 각 인덱스(레벨별 노드)에 리스트를 추가해주면 끝이나는 문제이다. medium 난이도의 문제이지만, 트리라는 자료구조를 사용해서 그런지 조금 난이도가 높게 측정이 된 것이 아닌가 하는 생각이 들었다.</p>
<p>queue 를 이용해 bfs를 할 수 있는 수준이면 무난하게 풀 수 있는 문제였다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        q = deque()</span><br><span class="line">        q.append((root, <span class="number">0</span>))</span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            node, lev = q.popleft()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> lev == <span class="built_in">len</span>(ans):</span><br><span class="line">                ans.append([])</span><br><span class="line"></span><br><span class="line">            ans[lev].append(node.val)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                q.append((node.left, lev + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                q.append((node.right, lev + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dooyeong20.github.io/2021/05/18/ps/boj-2580/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my.png">
      <meta itemprop="name" content="dooyeong">
      <meta itemprop="description" content="좋은 개발자 기술 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="두영's 지식 공간">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/18/ps/boj-2580/" class="post-title-link" itemprop="url">BOJ 2580 - 스도쿠</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">작성일</span>
      

      <time title="Post created: 2021-05-18 15:08:23 / Updated at: 15:14:50" itemprop="dateCreated datePublished" datetime="2021-05-18T15:08:23+09:00">2021-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Problem-Solving/" itemprop="url" rel="index"><span itemprop="name">Problem Solving</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Problem-Solving/BOJ/" itemprop="url" rel="index"><span itemprop="name">BOJ</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Problem-Solving-스도쿠-G4"><a href="#Problem-Solving-스도쿠-G4" class="headerlink" title="Problem Solving - 스도쿠(G4)"></a>Problem Solving - 스도쿠(G4)</h1><p>해당 문제는 <a target="_blank" rel="noopener" href="https://www.acmicpc.net/problem/2580">여기</a>에서 풀어볼 수 있습니다.</p>
<h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p>스도쿠는 18세기 스위스 수학자가 만든 ‘라틴 사각형’이랑 퍼즐에서 유래한 것으로 현재 많은 인기를 누리고 있다. 이 게임은 가로, 세로 각각 9개씩 총 81개의 작은 칸으로 이루어진 정사각형 판 위에서 이뤄지는데, 게임 시작 전 일부 칸에는 1부터 9까지의 숫자 중 하나가 쓰여 있다.</p>
<p>게임 시작 전 스도쿠 판에 쓰여 있는 숫자들의 정보가 주어질 때 모든 빈 칸이 채워진 최종 모습을 출력하는 프로그램을 작성하시오.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line"></span><br><span class="line">0 3 5 4 6 9 2 7 8</span><br><span class="line">7 8 2 1 0 5 6 0 9</span><br><span class="line">0 6 0 2 7 8 1 3 5</span><br><span class="line">3 2 1 0 4 6 8 9 7</span><br><span class="line">8 0 4 9 1 3 5 0 6</span><br><span class="line">5 9 6 8 2 0 4 1 3</span><br><span class="line">9 1 7 6 5 2 0 8 0</span><br><span class="line">6 0 3 7 0 1 9 5 2</span><br><span class="line">2 5 8 3 9 4 7 6 0</span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line"></span><br><span class="line">1 3 5 4 6 9 2 7 8</span><br><span class="line">7 8 2 1 3 5 6 4 9</span><br><span class="line">4 6 9 2 7 8 1 3 5</span><br><span class="line">3 2 1 5 4 6 8 9 7</span><br><span class="line">8 7 4 9 1 3 5 2 6</span><br><span class="line">5 9 6 8 2 7 4 1 3</span><br><span class="line">9 1 7 6 5 2 3 8 4</span><br><span class="line">6 4 3 7 8 1 9 5 2</span><br><span class="line">2 5 8 3 9 4 7 6 1</span><br></pre></td></tr></table></figure>

<h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><p>문제 조건에서 ‘항상 백트래킹으로 풀 수 있는 경우만 주어진다’ 라고 표시가 되어있기 때문에 백트래킹으로 풀어주었다. 제일 처음, 주어진 입력에 대해서 빈 칸의 인덱스들을 구해놓은 후, 해당 칸들에 1부터 9까지 차례대로 입력해주는데 입력하기 전 스도쿠 조건에 맞는지 매번 검사해주어 dfs 탐색 횟수를 크게 줄이는 것이 핵심이었던 것같다.</p>
<p>그리고 스도쿠 조건을 검사해주는 <code>check</code> 함수에서 일일이 for 문을 돌아주면서 가로, 세로, 3*3 정사각형을 검사해주었는데 지금 생각해보니 각각의 경우에 대해서 set 를 선언해주어 백트래킹시마다 해당 set에 add 와 remove 연산을 해주었다면 in 연산으로 O(1) 만에 탐색할 수도 있었겠다는 생각이 든다.</p>
<p>다음부터는 적절한 자료구조를 적극적으로 활용해 문제 해결의 효율성을 더욱 더 증가시켜야겠다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> stdin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getEmpty</span>(<span class="params">empty</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> board[i][j]:</span><br><span class="line">                empty.append((i, j))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> empty</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">board, r, c, cur</span>):</span></span><br><span class="line">    lc = (c // <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">    lr = (r // <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">        <span class="keyword">if</span> board[i][c] == cur <span class="keyword">and</span> i != r:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">        <span class="keyword">if</span> board[r][i] == cur <span class="keyword">and</span> i != c:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lr, lr + <span class="number">3</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(lc, lc + <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == cur <span class="keyword">and</span> (i, j) != (r, c):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">lev, empty</span>):</span></span><br><span class="line">    <span class="keyword">if</span> found[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lev == M:</span><br><span class="line">        found[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> board:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, b)))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    r, c = empty[lev]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> check(board, r, c, i):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        board[r][c] = i</span><br><span class="line">        dfs(lev + <span class="number">1</span>, empty)</span><br><span class="line">        board[r][c] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">N = <span class="number">9</span></span><br><span class="line">board = [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, stdin.readline().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">empty = getEmpty([])</span><br><span class="line">M = <span class="built_in">len</span>(empty)</span><br><span class="line">found = [<span class="literal">False</span>]</span><br><span class="line">dfs(<span class="number">0</span>, empty)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dooyeong20.github.io/2021/05/18/ps/prog-43238/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my.png">
      <meta itemprop="name" content="dooyeong">
      <meta itemprop="description" content="좋은 개발자 기술 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="두영's 지식 공간">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/18/ps/prog-43238/" class="post-title-link" itemprop="url">Programmers - 입국심사</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">작성일</span>
      

      <time title="Post created: 2021-05-18 14:00:00 / Updated at: 14:07:14" itemprop="dateCreated datePublished" datetime="2021-05-18T14:00:00+09:00">2021-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Problem-Solving/" itemprop="url" rel="index"><span itemprop="name">Problem Solving</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Problem-Solving/Programmers/" itemprop="url" rel="index"><span itemprop="name">Programmers</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Problem-Solving-입국-심사-level-3"><a href="#Problem-Solving-입국-심사-level-3" class="headerlink" title="Problem Solving - 입국 심사 (level 3)"></a>Problem Solving - 입국 심사 (level 3)</h1><p>해당 문제는 <a target="_blank" rel="noopener" href="https://programmers.co.kr/learn/courses/30/lessons/43238">여기</a>에서 풀어볼 수 있습니다.</p>
<h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><p>n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다.</p>
<p>처음에 모든 심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다.</p>
<p>모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다.</p>
<p>입국심사를 기다리는 사람 수 n, 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times가 매개변수로 주어질 때, 모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n: 6, times: [7, 10]</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure>

<h2 id="제한-사항"><a href="#제한-사항" class="headerlink" title="제한 사항"></a>제한 사항</h2><ul>
<li>입국심사를 기다리는 사람은 1명 이상 1,000,000,000명 이하입니다.</li>
<li>각 심사관이 한 명을 심사하는데 걸리는 시간은 1분 이상 1,000,000,000분 이하입니다.</li>
<li>심사관은 1명 이상 100,000명 이하입니다.</li>
</ul>
<h2 id="문제-풀이"><a href="#문제-풀이" class="headerlink" title="문제 풀이"></a>문제 풀이</h2><p>level 3 문제 치고는 매우 간단한 문제였다. 해당 문제가 이분 탐색 문제라는 것만 안다면 5분 이내에 풀 수 있을 정도의 문제였던 것같다.</p>
<p>이 문제의 핵심은 이분 탐색과 <code>check</code> 함수이다. <code>check</code> 함수에서는 시간이 매개변수로 주어지고, 해당 시간에 총 몇명의 입국 심사를 진행할 수 있는지 구해 그 값을 리턴해준다.</p>
<p>주어진 시간을 각 입국 심사관들이 심사하는 시간으로 나눈 몫 만큼의 사람들을 심사할 수 있다고 처리해주었고, 각각의 심사관들별로 이를 모두 구해주어 합산한 결과를 리턴해주도록 하였다.</p>
<p>그리고 이분 탐색의 경우, 위 결과값이 필요한 경우(총 인원)보다 많거나 같다면, 시간을 더 줄여도 된다는 뜻이기 때문에 <code>en</code> 값을 낮춰주었고, 반대로 적다면 <code>st</code> 를 증가시켜 주는 방식으로 탐색을 진행해주었다. 많거나 같을 때 시간을 줄인 이유는, 문제에서 요구한 요구사항이 최소 시간이었기 때문이다.</p>
<p>아래는 파이썬으로 풀이한 코드이다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">n, times</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">totalTime</span>):</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> times:</span><br><span class="line">            cnt += totalTime // t</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    st, en = <span class="number">1</span>, <span class="number">1000000000000000000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> st &lt;= en:</span><br><span class="line">        mid = (st + en) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> check(mid) &gt;= n:</span><br><span class="line">            en = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            st = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> en + <span class="number">1</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dooyeong20.github.io/2021/05/18/javascript/day14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my.png">
      <meta itemprop="name" content="dooyeong">
      <meta itemprop="description" content="좋은 개발자 기술 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="두영's 지식 공간">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/18/javascript/day14/" class="post-title-link" itemprop="url">JavaScript 14 - 객체 생성 (생성자)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">작성일</span>

      <time title="Post created: 2021-05-18 12:42:06" itemprop="dateCreated datePublished" datetime="2021-05-18T12:42:06+09:00">2021-05-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Updated at: 2021-05-21 17:23:07" itemprop="dateModified" datetime="2021-05-21T17:23:07+09:00">2021-05-21</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="객체-생성-생성자-사용"><a href="#객체-생성-생성자-사용" class="headerlink" title="객체 생성 (생성자 사용)"></a>객체 생성 (생성자 사용)</h1><p>앞서 객체 리터럴로 객체를 생성하는 법에 대해서 알아보았다. 이번에는 리터럴이 아니라 생성자 함수를 사용해 객체를 만드는 법에 대해서 알아보겠다.</p>
<p>하지만 생각보다 생성자 함수를 사용하는 빈도는 낮다. 왜냐하면 객체가 여러 개 필요하다면, (예를 들어서 TODO 리스트의 리스트 요소 객체의 경우) 함수를 만들어 객체 리터럴을 그때마다 리턴해주면 된다. 즉 반복문과 조합하면 어차피 여러 개를 만들 수 있다. 하지만 한 번에 한 개씩이 아니라 한 번에 여러 개의 객체가 동시에 생성되어야 한다면 객체 생성을 쓰면 되는 것이다.</p>
<h2 id="Object-생성자-함수"><a href="#Object-생성자-함수" class="headerlink" title="Object 생성자 함수"></a>Object 생성자 함수</h2><p><code>new</code> 연산자로 <code>Object</code> 생성자 함수를 호출하게 되면 비어있는 객체가 생성된다. 이후에 프로퍼티를 추가해 객체를 완성시킬 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">person.name = <span class="string">&#x27;Lee&#x27;</span>;</span><br><span class="line">person.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hi! My name is &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person);</span><br><span class="line"><span class="comment">// &#123;name: &quot;Lee&quot;, sayHello: ƒ&#125;</span></span><br></pre></td></tr></table></figure>

<p>이 때 말하는 생성자 함수란, 인스턴스를 생성하는 함수이다. 이 때 생성되는 객체가 바로 인스턴스가 되는 것이다. 그리고 자바스크립트에는 Object 이외에도 String, Number, Boolean, Function, Array 등 다양한 빌트인 생성자 함수가 존재한다.</p>
<h2 id="객체-리터럴-생성의-문제점"><a href="#객체-리터럴-생성의-문제점" class="headerlink" title="객체 리터럴 생성의 문제점"></a>객체 리터럴 생성의 문제점</h2><p>객체 리터럴로 객체를 생성하는 것은 직관적이고 간편하지만 이는 단 하나의 객체를 생성한다. 따라서 동일한 프로퍼티를 가진 객체를 많이 생성할 때에는 비효율적으로 코드가 중복되게 된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> circle1 = &#123;</span><br><span class="line">  radius: <span class="number">5</span>,</span><br><span class="line">  <span class="function"><span class="title">getDiameter</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">this</span>.radius;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle2 = &#123;</span><br><span class="line">  radius: <span class="number">10</span>,</span><br><span class="line">  <span class="function"><span class="title">getDiameter</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">this</span>.radius;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>객체는 고유의 상태를 프로퍼티를 통해서 표현하는데, 같은 상태를 가진 객체를 여러 개 생성해야 할 경우 매번 같은 프로퍼티와 메서드를 기술해야 하기 때문에 비효율적이다.</p>
<h2 id="생성자-함수에-의한-객체-생성의-장점"><a href="#생성자-함수에-의한-객체-생성의-장점" class="headerlink" title="생성자 함수에 의한 객체 생성의 장점"></a>생성자 함수에 의한 객체 생성의 장점</h2><p>생성자 함수로 객체를 생성할 때에는 미리 인스턴스 생성을 위한 틀을 만들어 놓고 이를 재사용하기 때문에 동일한 객체 여러 개를 효율적으로 생성할 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.radius = radius;</span><br><span class="line">  <span class="built_in">this</span>.getDiameter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">this</span>.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> Circle(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>이 때 <code>this</code> 라는 키워드를 볼 수 있는데, 이는 본인의 프로퍼티 혹은 메서드를 참조하기 위한 자기 참조 변수이다. 즉, <code>this</code> 바인딩은 함수 호출 방식에 따라서 동적으로 결정되는 것이다.</p>
<ul>
<li>일반 함수로 호출: 전역 객체</li>
<li>메서드로 호출: 메서드를 호출한 객체(‘.’ 앞의 객체)</li>
<li>생성자 함수로 호출: 생성자 함수가 생성할 인스턴스</li>
</ul>
<p>이 <code>this</code> 라는 것은 아주 중요한 키워드이기 때문에 헷갈리지 않도록 확실히 정리해야할 필요가 있다.</p>
<p>앞서 살펴본 lexical scope 는 정적으로 선언된 곳을 기준으로 스코프를 결정했었다. 하지만 <code>this</code> 가 결정될 때는 동적으로 결정이 된다는 점이 매우 중요하다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 일반적인 함수로서 호출</span></span><br><span class="line">foo(); <span class="comment">// window(or global)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 메서드로서 호출</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; foo &#125;;</span><br><span class="line">obj.foo(); <span class="comment">// obj</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 함수로서 호출채ㅜㄴ</span></span><br><span class="line"><span class="keyword">const</span> inst = <span class="keyword">new</span> foo(); <span class="comment">// inst</span></span><br></pre></td></tr></table></figure>

<p>아래 결과를 예측해보자.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123;</span><br><span class="line">  p: <span class="built_in">this</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o1.p); <span class="comment">// ?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o2 = &#123;</span><br><span class="line">  f: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(o1.p);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">o2.f(); <span class="comment">// ?</span></span><br><span class="line"><span class="keyword">new</span> o2.f(); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>결과는 둘 다 전역객체(window or global)이다. 이렇듯 <code>this</code> 는 매우 변덕스럽기 때문에 잘 알고 써야한다. <code>this</code> 에 대한 더 자세한 내용은 뒤에서 따로 정리하도록 하겠다.</p>
<h2 id="생성자-함수의-인스턴스-생성-과정"><a href="#생성자-함수의-인스턴스-생성-과정" class="headerlink" title="생성자 함수의 인스턴스 생성 과정"></a>생성자 함수의 인스턴스 생성 과정</h2><p>생성자 함수의 역할에 대해서 생각해보면, 생성자 함수는 인스턴스를 생성하는 것과 생성된 인스턴스를 초기화(인스턴스 프로퍼티 추가 및 초기값 할당)해야한다. 생성자 함수가 인스턴스를 생성하는 것은 물론 필수이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.radius = radius;</span><br><span class="line">  <span class="built_in">this</span>.getDiameter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">this</span>.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>생성자 함수 <code>Circle</code> 의 내부를 보면, <code>this</code>에 프로퍼티를 추가하고 값을 초기화해준다. 하지만 인스턴스 생성 및 반환 코드를 찾아볼 수는 없다.</p>
<p>왜냐하면 자바스크립트 엔진은 암묵적으로 내부에서 인스턴스를 생성해서 반환하기 때문이다. <code>new</code> 연산자와 함께 생성자 함수를 호출하게 되면 아래와 같은 과정을 거쳐 인스턴스를 반환하게 된다.</p>
<ol>
<li><p>인스턴스 생성 및 <code>this</code> 바인딩<br>암묵적으로 빈 객체가 생성된 후 <code>this</code> 에 바인딩 된다.</p>
</li>
<li><p>인스턴스 초기화<br><code>this</code> 에 바인딩 되어있는 인스턴스를 초기화한다. 해당 과정은 개발자가 기술한 내용대로 실행된다.</p>
</li>
<li><p>인스턴스 반환<br>모든 처리가 끝나면 완성된 인스턴스가 바인딩된 <code>this</code> 가 암묵적으로 반환이 된다.</p>
</li>
</ol>
<p>주의할 점은, <code>return</code> 문을 통해서 명시적으로 객체를 반환할 경우, 해당 객체가 리턴이 된다는 점이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.getDiameter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">this</span>.radius;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(circle); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>그런데 명시적으로 원시값을 리턴할 경우에는 원시값이 무시되고 바인딩 된 <code>this</code> 가 반환되게 된다.</p>
<p>따라서 정상적인 동작을 위해서 생성자 함수 내부에서는 <code>return</code> 문을 생략해야 한다.</p>
<h3 id="중복된-프로퍼티"><a href="#중복된-프로퍼티" class="headerlink" title="중복된 프로퍼티"></a>중복된 프로퍼티</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hello my name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// this.sayHi() &#123; ~~~ &#125;</span></span><br><span class="line">  <span class="comment">// this로 표현할 때는 메서드 축약표현을 사용할 수 없다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> you = <span class="keyword">new</span> Person(<span class="string">&#x27;Kim&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> park = <span class="keyword">new</span> Person(<span class="string">&#x27;Park&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>위 코드에서 name 프로퍼티는 각각의 인스턴스마다 고유의 값을 가지고 있기 때문에 인스턴스의 프로퍼티로 <code>name</code> 이라는 키를 각자 가지게 하는 것은 합당해보인다. 하지만 <code>sayHi</code> 의 경우에는 어떨까?</p>
<p><code>sayHi</code> 는 같은 인스턴스들에 상관없이 항상 같은 동작을 하면서도 인스턴스의 수 만큼 메서드가 계속 새로 생성이 된다. 이는 합당해보이지 않는다. 따라서 이러한 경우에는 <code>Person</code> prototype에 sayHi 메서드를 추가해 공통적으로 소유하는 것이 합리적일 것이다.</p>
<h2 id="constructor-amp-non-constructor"><a href="#constructor-amp-non-constructor" class="headerlink" title="constructor &amp; non-constructor"></a>constructor &amp; non-constructor</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> baz = &#123;</span><br><span class="line">  x: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, <span class="comment">// 프로퍼티 x의 값으로 할당된 것은 일반 함수로 정의된 함수다. 이는 메서드로 인정하지 않는다.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> foo(); <span class="comment">// 가능</span></span><br><span class="line"><span class="keyword">new</span> bar(); <span class="comment">// 가능</span></span><br><span class="line"><span class="keyword">new</span> baz.x(); <span class="comment">// 가능</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrow = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">new</span> arrow(); <span class="comment">// TypeError: arrow is not a constructor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">x</span>(<span class="params"></span>)</span> &#123;&#125;, <span class="comment">// 메서드 정의: ES6의 메서드 축약 표현만을 메서드로 인정한다.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> obj.x(); <span class="comment">// TypeError: obj.x is not a constructor</span></span><br></pre></td></tr></table></figure>

<p>즉 모든 함수는 callable 하지만 모든 함수가 constructor 로써 동작하지는 않는다는 것을 확인할 수 있다.<br><code>new</code> 연산자를 붙인다 하더라도 arrow function과 ES6 문법의 축약 표현 메서드는 constructor 로써 사용할 수 없는 것이다.</p>
<h2 id="일반-함수로써의-this"><a href="#일반-함수로써의-this" class="headerlink" title="일반 함수로써의 this"></a>일반 함수로써의 this</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.radius = radius;</span><br><span class="line">  <span class="built_in">this</span>.getDiameter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">this</span>.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle = Circle(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 일반 함수 내부의 this는 전역 객체 window를 가리킨다.</span></span><br><span class="line"><span class="comment">// 따라서 Circle 함수가 동작하며 this.radius =&gt; window.radius 를 지정해주어 전역적으로 사용할 수 있게 된 것이다. (브라우저)</span></span><br><span class="line"><span class="built_in">console</span>.log(radius); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>일반 함수와 생성자 함수에 특별한 형식적 차이는 없기 때문에 생성자 함수는 일반적으로 첫 문자를 대문자로 기술하는 파스칼 케이스로 명명하여 일반 함수와 구별할 수 있도록 노력하는 것이 일반적이다.</p>
<h2 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h2><p>생성자 함수를 일반 함수와 구분하기 위해 파스칼 케이스를 사용한다고 하더라도 실수가 발생할 수 있다. 따라서 ES6 부터는 new.target 을 지원해 실수를 회피할 수 있도록 한다</p>
<p>new.target 은 <code>this</code> 와 유사하게 constructor 함수 내부에서 암묵적인 지역 변수로 사용되며 메타 프로퍼티라고 부른다. (IE 는 new.target을 지원하지 않는다.)</p>
<p>함수 내부에서 new.target을 사용하면 new 연산자와 함께 생성자 함수로 호출되었는지, 아닌지를 확인할 수 있게 된다.</p>
<p>new 연산자와 함께 생성자 함수로서 호출되면 함수 내부의 new.target은 함수 자신을 가리킨다. new 연산자 없이 일반 함수로서 호출된 함수 내부의 new.target은 undefined다.</p>
<p>따라서 new.target 을 통해서 한 번 확인을 한 후, new 연산자를 통해서 호출이 되지 않은 경우에는 재귀적으로 다시 new 연산자와 함께 자기 자신을 호출해 반환하는 것이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 이 함수가 new 연산자와 함께 호출되지 않았다면 new.target은 undefined다.</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.target) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Circle(radius);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IE 와 같이 new.target 을 지원하지 않는 경우에는 스코프 세이프 생성자 패터을 활용하면 된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Scope-Safe Constructor Pattern</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 일반 함수로 호출된 경우</span></span><br><span class="line">  <span class="keyword">if</span> (!(<span class="built_in">this</span> <span class="keyword">instanceof</span> Circle)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Circle(radius);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.radius = radius;</span><br><span class="line">  <span class="built_in">this</span>.getDiameter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">this</span>.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Object, Function 등 대부분의 경우에는 위와 같은 패턴으로 new 를 붙였을 때와 아닐 때 동일하게 객체를 반환한다. 하지만 String, Number, Boolean 생성자 함수는 new 연산자와 함께 호출했을 때 String, Number, Boolean 객체를 생성하여 반환하며 new 연산자 없이 호출하면 문자열, 숫자, 불리언 값을 반환한다.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="이전 페이지"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="다음 페이지"></i></a>
  </nav>
<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dooyeong</span>
</div>

    </div>
  </footer>

  
  <script size="100" alpha="0.3" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  <script class="next-config" data-name="nprogress" type="application/json">{&quot;enable&quot;:true,&quot;spinner&quot;:true}</script>
  <script src="/js/third-party/nprogress.js"></script>

  





</body>
</html>
